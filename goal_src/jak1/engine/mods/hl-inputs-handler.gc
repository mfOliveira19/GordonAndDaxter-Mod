(in-package goal)

(defun in-hl-state? ()
  (and (= (-> *target* game mode) 'play) (or (-> *target* state name) 'target-hl-movement-ground 'target-hl-movement-ground-duck 'target-hl-movement-air 'target-hl-movement-air-duck) (!= (-> *target* state name) 'target-hl-periscope) (!= (-> *target* state name) 'target-hl-death) (!= (-> *target* state name) 'target-hl-fishing)))

(defun should-jump? ()
  ;;(or (< (-> *mouse-data* mouse-scrolly) 0.0) (when *auto-jump* (cpad-hold? 0 x)) (cpad-pressed? 0 x))
  (or (< (-> *mouse-data* mouse-scrolly) 0.0) (when *auto-jump* (!= (-> *keyboard-data* key_space) 0)))
)

(defun should-move-forward? ()
  ;;(< (-> *cpad-list* cpads 0 lefty) 127)
  (!= (-> *keyboard-data* key_w) 0)
)

(defun should-move-back? ()
  ;;(> (-> *cpad-list* cpads 0 lefty) 127)
  (!= (-> *keyboard-data* key_s) 0)
)

(defun should-move-left? ()
  ;;(< (-> *cpad-list* cpads 0 leftx) 127)
  (!= (-> *keyboard-data* key_a) 0)
)

(defun should-move-right? ()
  ;;(> (-> *cpad-list* cpads 0 leftx) 127)
  (!= (-> *keyboard-data* key_d) 0)
)

(defun should-be-moving? ()
  (or (should-move-forward?) (should-move-back?) (should-move-left?) (should-move-right?))
)

(defun should-duck? ()
  ;;(or (> (-> *mouse-data* mouse-scrolly) 0.0) (cpad-hold? 0 l1))
  (or (> (-> *mouse-data* mouse-scrolly) 0.0) (!= (-> *keyboard-data* key_ctrl) 0))
)

(defun should-walk? ()
  ;;(cpad-hold? 0 r1)
  (!= (-> *keyboard-data* key_shift) 0)
)

(defun should-reload? ()
  (and (!= (-> *target* state name) 'target-hl-death) (!= (-> *keyboard-data* key_r) 0))
)

(defun should-attack? ()
  (and (in-hl-state?) (!= (-> *mouse-data* mouse1) 0)))

(defun mouse1? ()
  (!= (-> *mouse-data* mouse1) 0))

(defun should-second-attack? ()
  (and (in-hl-state?) (!= (-> *mouse-data* mouse2) 0))
)

(defun should-switch-slot1? ()
  (!= (-> *keyboard-data* key_1) 0)
)

(defun should-switch-slot2? ()
  (!= (-> *keyboard-data* key_2) 0)
)

(defun should-switch-slot3? ()
  (!= (-> *keyboard-data* key_3) 0)
)

(define *last-e-state* 0)

(defun should-use? ()
  (let ((pressed (-> *keyboard-data* key_e))
        (should-switch #f))
    ;; Detect rising edge — pressed now, not pressed before
    (when (and (!= pressed 0) (= *last-e-state* 0))
      (set! should-switch #t))
    ;; Update state for next frame
    (set! *last-e-state* (the-as int pressed))
    should-switch)
)

(defun should-exit? ()
  (!= (-> *keyboard-data* key_esc) 0)
)

(define *last-q-state* 0)

(defun should-switch-last-weapon? ()
  (let ((pressed (-> *keyboard-data* key_q))
        (should-switch #f))
    ;; Detect rising edge — pressed now, not pressed before
    (when (and (!= pressed 0) (= *last-q-state* 0))
      (set! should-switch #t))
    ;; Update state for next frame
    (set! *last-q-state* (the-as int pressed))
    should-switch))

(defbehavior read-input target ((arg0 vector))
  (when (!= (-> self control pad-read-time) (-> *display* real-frame-counter))
    (set! (-> self control last-stick-vec quad) (-> self control stick-vec quad))
    (set! (-> self control last-pad-stick-speed) (-> self control pad-stick-speed))
    (set! (-> self control pad-read-time) (the-as uint (-> *display* real-frame-counter))))

  ;; start clean
  (set! (-> arg0 x) 0.0)
  (set! (-> arg0 y) 0.0)
  (set! (-> arg0 z) 0.0)
  (set! (-> arg0 w) 0.0)

  ;; build input vector
  (when (should-move-forward?) (set! (-> arg0 z) (+ (-> arg0 z) 1.0)))
  (when (should-move-back?)    (set! (-> arg0 z) (- (-> arg0 z) 1.0)))
  (when (should-move-left?)    (set! (-> arg0 x) (+ (-> arg0 x) 1.0)))
  (when (should-move-right?)   (set! (-> arg0 x) (- (-> arg0 x) 1.0)))

  (let ((has-input (> (vector-length arg0) 0.0)))
    (if has-input
        ;; when input exists
        (begin
          (vector-normalize! arg0 1.0)
          (set! (-> self control stick-vec quad) (-> arg0 quad))
          (let ((base-speed (if (should-walk?) 0.5 1.5)) ;; was 1.5
                (duck-mult (if (should-duck?) 0.333 1.0)))
            (set! (-> self control pad-stick-speed) (* base-speed duck-mult)))
          (vector-matrix*! arg0 arg0 (matrix-local->world #t #f))
))))

(defun get-camera-pitch ()
  (-> (the-as camera-slave (-> *camera* slave 0))
      tracking inv-mat vector 0 w))
