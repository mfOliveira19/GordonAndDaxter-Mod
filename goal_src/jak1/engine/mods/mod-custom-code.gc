;;-*-Lisp-*-
(in-package goal)
(require "engine/mods/hl-weapons/hl-weapons.gc")

;; name: mod-custom-code.gc
;; name in dgo: mod-custom-code
;; dgos: TODO

;;;;;;;;;;;;;;;;;;;;;;;;;;
;; What is this file for.
;;;;;;;;;;;;;;;;;;;;;;;;;;

#|
 This file contains function defenitions that are pre placed in the mod base,
    so if you place custom code inside of these functions, it will exectue based on
    the name of the function, for example, if you place (set! (-> *game-info* fuel) (+ (-> *game-info* fuel) 1))
    to the function named runs-on-orb-pickup, then jaks powercell count will increase each time you collect
    an orb
|#

;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Begin function defintions.
;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun on-zoomer? ()
  (or (= (-> *target* state name) 'target-hl-racing)
  (= (-> *target* state name) 'target-hl-racing-grab)
  (= (-> *target* state name) 'target-hl-racing-clone-anim)
  (= (-> *target* state name) 'target-hl-racing-hit) 
  (= (-> *target* state name) 'target-hl-racing-jump)
  (= (-> *target* state name) 'target-hl-racing-smack)
  (= (-> *target* state name) 'target-hl-racing-bounce)
  (= (-> *target* state name) 'target-hl-racing-falling)
  (= (-> *target* state name) 'target-hl-racing-start)
  (= (-> *target* state name) 'target-hl-racing-get-on)
  (= (-> *target* state name) 'target-hl-racing-get-off)
  (= (-> *target* state name) 'target-hl-racing-get-off-jump)
  (= (-> *target* state name) 'target-hl-racing-get-off-hit-ground)
  (= (-> *target* state name) 'target-hl-racing-death)
  ))
(defun in-hl-state? ()
  (let ((st (-> *target* state name)))
    (and
      (= (-> *target* game mode) 'play)

      ;; explicitly exclude these states
      (not (or (= st 'target-hl-periscope)
               (= st 'target-hl-death)
               (= st 'target-title)
               (= st 'target-title-play)
               (= st 'target-final-door)
               (= st 'target-title-wait)
               (= st 'target-hl-fishing)
               (= st 'target-hl-clone-anim)
               (on-zoomer?))))))

(defun target-sleeping? ()
  (nonzero? (logand (-> *target* mask)
                    (process-mask sleep))))

(defun show-viewmodel-and-hud ()
  (logclear! (-> *hl-weapons* mask) (process-mask sleep))
  (hud-hl-display-on)
  (pc-set-viewmodel-enabled #t)
  (pc-set-crosshair-enabled #t))

(defun hide-viewmodel-and-hud ()
  (logior! (-> *hl-weapons* mask) (process-mask sleep))
  (hud-hl-display-off)
  (pc-set-viewmodel-enabled #f)
  (pc-set-crosshair-enabled #f))

(defun green-screen ()
  (with-dma-buffer-add-bucket ((dma-buf (-> (current-frame) global-buf)) (bucket-id debug-no-zbuf))
    (draw-sprite2d-xy dma-buf 0 0 512 224 (new 'static 'rgba :r #x00 :g #xCC :b #x00 :a #x60))) (none))

(defun start-green-flash ((times int))
  (set! *green-flash-times* times)
  (set! *green-flash-started* #f)
  (set! *green-flash-active* #t)
  (set! *green-flash-current* 0))

(defun swim-screen ()
  (with-dma-buffer-add-bucket ((dma-buf (-> (current-frame) global-buf)) (bucket-id debug-no-zbuf))
    (draw-sprite2d-xy dma-buf 0 0 512 224 (new 'static 'rgba :r #x00 :g #x00 :b #xCC :a #x20))) (none))

(defun swim-screen-misty ()
  (with-dma-buffer-add-bucket ((dma-buf (-> (current-frame) global-buf)) (bucket-id debug-no-zbuf))
    (draw-sprite2d-xy dma-buf 0 0 512 224 (new 'static 'rgba :r #x00 :g #x50 :b #x00 :a #x20))) (none))

(defun update-green-flash ()
  (when *green-flash-active*
    ;; if we're not in a flash, wait for the gap
    (when (not *green-flash-started*)
      (when (or (not *green-flash-last-time*) ;; first flash
                (time-elapsed? *green-flash-last-time* *green-flash-gap-sec*))
        ;; start current flash
        (set! *show-green-screen?* #t)
        (set-time! *green-flash-time*)
        (set! *green-flash-started* #t))))

    ;; draw green screen while time has not elapsed
    (when *show-green-screen?*
      (green-screen))

    ;; check if current flash duration has finished
    (when (and *green-flash-started*
               (time-elapsed? *green-flash-time* *green-flash-duration-sec*))
      ;; end current flash
      (set! *show-green-screen?* #f)
      (set! *green-flash-started* #f)
      (set! *green-flash-current* (+ *green-flash-current* 1))
      ;; store the end time to wait for the gap
      (set-time! *green-flash-last-time*)

      ;; stop flashing if reached total
      (when (>= *green-flash-current* *green-flash-times*)
        (set! *green-flash-active* #f))))


(defun handle-draw-and-input-stuff ()
  ;; Set the camera to first-person when we are a normal state (ground, air, etc.) and not in a cutscene
  (when (or (and (in-hl-state?) (not (movie?)) (not (on-zoomer?))) (= (-> *target* state name) 'target-hl-death))
    (send-event *camera* 'set-fov 16384.845)
    (send-event *camera* 'change-state cam-fps 0))

  ;; In the zoomer we set the camera back to string
  (when (on-zoomer?)
    (send-event *camera* 'change-state cam-string 0))

  ;; Handle input and new hints when not paused
  (when (and (not (paused?)) (not (target-sleeping?)))
    (hud-hl-display-on)
    (unless (= (-> *target* state name) 'target-warp-in) (update-mouse-input-stuff))
    (pc-set-crosshair-enabled #t)
    (update-cell-suit-upgrade-status)
    (update-suit-upgrade-message))

  ;; When we should hide the viewmodel and hud
  ;;  
  ;; Hide when we are not in first person or not in play, we also hide target
  (if (or (!= *camera-look-through-other* 0) (!= (-> *target* game mode) 'play) (not (in-hl-state?)) (movie?) (and (= (-> *target* state name) 'target-hl-grab) (= (-> *target* current-level name) 'swamp)))
    (begin
      (hide-viewmodel-and-hud)
      ;; We also hide the target when we die
      (unless (= (-> *target* state name) 'target-hl-death)
        (send-event *target* 'draw #t))
    )
    (begin
      (show-viewmodel-and-hud)
      (send-event *target* 'draw #f)
    )
  )

  ;; Handle pausing the viewmodel
  (if (paused?)
    (pc-set-viewmodel-paused #t)
    (pc-set-viewmodel-paused #f))

  (when (or (= (-> *target* state name) 'target-hl-clone-anim))
    (set! *should-blackout?* #f)
  )

  (when (and (= (-> *target* current-level name) 'misty) (= (-> *target* state name) 'target-hl-grab))
    (send-event *camera* 'set-fov 16384.845))

  ;; Force blackout during target warp transitions
  (when *should-blackout?* (blackout))

  ;; Swim screen effect
  (when *should-show-swim-screen?*
    (if (= (-> *target* current-level name) 'misty)
    (swim-screen-misty)
    (swim-screen)))

  ;; So we are not staring at the teleported after the first cutscene after beating geyser
  (when *in-cutscene-after-geyser*
    (when (not (movie?))
      (set! *do-180?* #t)
      (set! *in-cutscene-after-geyser* #f)))

  ;; Handle the green screen teleport effect
  (update-green-flash)
  0
)


(defun runs-every-frame ()
  (if *show-input-display* (input-display-on) (input-display-off))
  ;;(set! *display-collision-marks* #t)
  (update-keyboard-input-stuff)
  (should-update-jump-buffer?)
  (handle-draw-and-input-stuff)
  ;; ensure orb-placer is spawned/killed as requested, debug menu is updated
  (when *debug-segment*
    (orb-placer-maintenance))
  (none))

(defun runs-on-orb-pickup ((parent process-tree))
  (let* ((from-cache? (and parent (type-type? (-> parent type) orb-cache-top))))
    ;; Code here runs on ANY orb pickup
    (when from-cache?
      ;; Code here runs only if the orb was from an orb cache
      )
    (when (not from-cache?)
      ;; Code here runs only if the orb was NOT from an orb cache
      ))
  (none))

(defun runs-on-fly-pickup ()
  ;; Code here runs on any scout fly pickup
  (none))

(defun runs-on-cell-pickup ((cell-event symbol))
  (case cell-event
    (('pickup)
     ;; Code here runs as soon as you pickup a powercell
     )
    (('cutscene-end)
     ;; Code here runs at the end of any powercell cutscene
     ))
  (none))

(defun runs-on-eco-pickup ((eco-type pickup-type) (parent process-tree))
  (let* ((from-vent? (and parent (type-type? (-> parent type) vent))))
    ;; Code here runs as soon as you pickup ANY eco
    (case eco-type
      (((pickup-type eco-yellow))
       ;; Code here runs as soon as you pickup yellow eco
       )
      (((pickup-type eco-red))
       ;; Code here runs as soon as you pickup red eco
       )
      (((pickup-type eco-blue))
       ;; Code here runs as soon as you pickup blue eco
       )
      (((pickup-type eco-pill))
       ;; Code here runs as soon as you pickup small green eco
       )
      (((pickup-type eco-green))
       ;; Code here runs as soon as you pickup big green eco 
       ))
    (when from-vent?
      ;; Code here runs only if the eco was picked up from a vent
      ))
  (none))

(defun runs-on-jak-spawn ()
  ;; Code here runs every time jak spawns (loading a file new game or death)
  ;;uncomment this to use custom music for custom levels - the function is in mod-common-functions.gc
  ;;(process-spawn-function process music-manager-proc)
    (pc-set-fog-intensity 1.0)
    (set! *should-show-swim-screen?* #f)
    (when (not (process-by-name 'hl-weapon-proc *active-pool*))
      (start-hl-weapons))
  (none))

(defun runs-on-jak-death ((death-event symbol))
  (case death-event
    (('dying)
     ;; Code here runs immediately every time jak dies, before any death animation or death cutscene
     )
    (('blackout)
     ;; Code here runs after jak dies (and any death cutscene finishes), during the blackout before he spawns
     ))
  (none))

(defun runs-on-jak-init ()
    ;; Code here runs on target init
    ;; Init the timers, for some reason, when we load the game sometimes the timers are fucked up
    (set! *hl-target-jump-buffer* 0)
    (set! *last-duck-time* 0)
    (set! *last-step-time* 0)
    (set! *hl-target-explosion-invinc-time* 0)
    (if (not (process-by-name 'hl-weapon-proc *active-pool*))
      (start-hl-weapons)
      (reset-hl-weapon-stuff))
  (none))

;;;;;;;;;;;;;;;;;;;;;;;;;;
;; deprecated function defintions.
;;;;;;;;;;;;;;;;;;;;;;;;;;

#| these are no longer recommended/supported however we include them anyways to not break anyones mods. |#
