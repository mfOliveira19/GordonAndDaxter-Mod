(in-package goal)
(require "engine/mods/mod-common-functions.gc")

(defconstant hl-explosion-invinc-time (seconds 0.2))
(define *last-cell-val* 0)
(define *hl-target-explosion-invinc-time* 0)
(define *suit-upgrade-active* #f)
(define *suit-upgrade-val* 0)
(define *suit-upgrade-time* 0.0)
(define *suit-upgrade-duration* 6.0) ;; seconds on screen

(defun start-suit-upgrade-message ((val int))
  (set! *suit-upgrade-active* #t)
  (set! *suit-upgrade-val* val)
  (set! *suit-upgrade-time* 0.0))

(defun print-suit-upgrade-info ((val int))
  (let ((a1-3
          (new 'stack 'font-context *font-default-matrix* 56 160 0.0 (font-color default) (font-flags shadow kerning))
          )
        )
    (set-width! a1-3 400)
    (set-height! a1-3 96)
    (set! (-> a1-3 flags) (font-flags shadow kerning middle large))
      (cond
        ((= val 20) (print-game-text "YOUR SUIT CAN NOW WALK ON FIRE CANYON" a1-3 #f 128 22))
        ((= val 72) (print-game-text "YOUR SUIT CAN NOW WALK ON LAVA TUBE" a1-3 #f 128 22)))))

;; We are using the total-deaths value from the saves to store the hints display status
(defun check-cell-suit-upgrade ((val int))
  (let* ((fuel (the int (-> *game-info* fuel)))
         (last-hint (the int (-> *game-info* total-deaths))))
    (cond
      ((and (= val 20)
            (< *last-cell-val* val)
            (>= fuel val)
            (< last-hint 1))
       (sound-play "cell-reach-20")
       (start-suit-upgrade-message val)
       (set! (-> *game-info* total-deaths) 1))

      ((and (= val 72)
            (< *last-cell-val* val)
            (>= fuel val)
            (< last-hint 2))
       (sound-play "cell-reach-72")
       (start-suit-upgrade-message val)
       (set! (-> *game-info* total-deaths) 2))

      ((and (= val 100)
            (< *last-cell-val* val)
            (>= fuel val)
            (< last-hint 3))
       (sound-play "cell-reach-100")
       (start-suit-upgrade-message val)
       (set! (-> *game-info* total-deaths) 3)))))

(defun update-suit-upgrade-message ()
  (when *suit-upgrade-active*
    ;; advance timer
    (set! *suit-upgrade-time*
          (+ *suit-upgrade-time* (seconds-per-frame)))

    ;; draw text
    (print-suit-upgrade-info *suit-upgrade-val*)

    ;; timeout
    (when (>= *suit-upgrade-time* *suit-upgrade-duration*)
      (set! *suit-upgrade-active* #f))))

(defun update-cell-suit-upgrade-status ()
  (check-cell-suit-upgrade 20)
  (check-cell-suit-upgrade 72)
  (check-cell-suit-upgrade 100)
  (set! *last-cell-val* (the int (-> *game-info* fuel))))

(defbehavior target-should-take-lava-damage? target ((arg1 attack-info))
  ;; We only check if the attack type is burnup or burn
  (if (or (= (-> arg1 mode) 'burnup) (= (-> arg1 mode) 'burn))
    (cond
      ;; If we are in firecanyon and we have at least 20 cells
      ((and (= (-> self current-level name) 'firecanyon) (>= (the int (-> *game-info* fuel)) 20))
        #f)
      ;; If we are in lavatube and we have at least 72 cells
      ((and (= (-> self current-level name) 'lavatube) (>= (the int (-> *game-info* fuel)) 72))
        #f)
      (else
      #t)
    )
#t))

(defbehavior target-hl-explosion-handler target ((arg0 symbol) (arg1 attack-info) (arg2 process) (arg3 touching-shapes-entry) (arg4 (state symbol attack-info target)) (arg5 event-message-block))
  ;; Only process if invincibility timer allows
  (when (time-elapsed? *hl-target-explosion-invinc-time* hl-explosion-invinc-time)

    ;; Update invincibility timer
    (set-time! *hl-target-explosion-invinc-time*)

    (when arg3
      (let ((hit-prim (prims-touching? arg3 (-> self control) (the-as uint -1))))
        (when hit-prim
          (get-intersect-point (-> self attack-info-rec intersection) hit-prim (-> self control) arg3)
          (logior! (-> self attack-info-rec mask) (attack-mask intersection)))))
    #|
    (format 0 "Explosion pos: ~6,,2m ~6,,2m ~6,,2m~%" 
            (-> *grenade-explosion-position* x)
            (-> *grenade-explosion-position* y)
            (-> *grenade-explosion-position* z))|#

    ;; ----- Apply explosion push -----
    (let* ((explosion-pos *grenade-explosion-position*)
          (player-pos    (-> self control trans))
          (radius        (meters 5.0))

          ;; horizontal difference
          (dx (- (-> player-pos x) (-> explosion-pos x)))
          (dz (- (-> player-pos z) (-> explosion-pos z)))
          (dy (- (-> player-pos y) (-> explosion-pos y)))

          (dist-xz (sqrtf (+ (* dx dx) (* dz dz))))

          ;; falloff (0..1)
          (raw-t (max 0.0 (- 1.0 (/ dist-xz radius))))
          (t (sqrtf raw-t))   ;; slow dropoff curve

          ;; smooth horizontal shaping
          (horizontal-strength (- 1.0 (* t t)))  ; stronger near edge
          (vertical-strength   t))               ; strongest at center

      (when (> t 0.0)
        (let ((dir (new 'stack-no-clear 'vector)))

          ;; horizontal direction (unit-length)
          (if (> dist-xz 0.001)
              (set-vector! dir (/ dx dist-xz)
                              0.0
                              (/ dz dist-xz)
                              0.0)
              (set-vector! dir 0.0 0.0 0.0 0.0))

          ;; scale horizontal AFTER normalization
          (set! (-> dir x) (* (-> dir x) horizontal-strength))
          (set! (-> dir z) (* (-> dir z) horizontal-strength))

          (if (> dy -2800.0)
              (begin
              (format 0 "ALLOW LIFT ~f ~%" dy)
              ;; explosion below player -> allow lift
              (set! (-> dir y)
                    (* vertical-strength 0.5))
              )
              ;; explosion above or level no upward push
              (begin
              (format 0 "NO LIFT ~f ~%" dy) 
              (set! (-> dir y) 0.0)
              ))


          (when (> (-> dir y) 0)
            (if (should-duck?) (go target-hl-movement-air-duck) (go target-hl-movement-air)))

          (let* ((base-force 100000.0)
                (len (vector-length dir))
                (scaled-force
                  (if (> len 0.001)
                      (/ (* base-force t) len)
                      0.0)))
            (vector+! (-> self control transv)
                      (-> self control transv)
                      (vector-float*! (new-stack-vector0) dir scaled-force)))

                      
          ))
          
          )))

(defstate target-hl-hit-ground (target)
  :enter
    (behavior ((arg0 symbol))
      (cond
        ((= arg0 'stuck))
        ((let ((v1-4 (ja-group))) (or (= v1-4 eichar-launch-jump-ja) (= v1-4 eichar-launch-jump-loop-ja)))
         (effect-control-method-10 (-> self skel effect) 'group-blue-hit-ground-effect (the-as float 0.0) -1)
         (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 255 (seconds 0.3)))
        (else
         (let ((f0-1 (vector-dot (-> self control dynam gravity-normal)
                                 (vector-! (new 'stack-no-clear 'vector) (-> self control last-air-trans) (-> self control trans)))))
           #|                      
           (if (and (< (-> *TARGET-bank* fall-far) f0-1) (not (logtest? (-> self control status) (cshape-moving-flags on-water))))
             (go target-hit-ground-hard f0-1))|#
             )))
      #|(cond
        ((= arg0 'stuck))
        (else (target-land-effect)))|#
      (set! (-> self control hands-used-time) 0)
      (set! (-> self control feet-used-time) 0)
      (if (>= (-> self control ground-impact-vel) (-> *TARGET-bank* fall-stumble-threshold)) (set-forward-vel (the-as float 0.0)))
      (if (!= (-> self control ground-pat material) (pat-material ice)) (delete-back-vel))
      (set! (-> self control cur-surf) *walk-mods*)
      (start-bobbing! (-> self water)
                      (lerp-scale (the-as float 0.0)
                                  (the-as float 4096.0)
                                  (-> self control ground-impact-vel)
                                  (the-as float 40960.0)
                                  (the-as float 102400.0))
                      600
                      1500))
  :trans
    (behavior ()
      )
  :code
    (behavior ((arg0 symbol))
      ;;(target-hit-ground-anim #f)
      (go target-hl-movement-ground))
  :post target-hl-movement-post)

(defbehavior target-hl-hit-effect target ((arg0 attack-info))
  (let ((v1-9 (-> arg0 mode)))
    (cond
      ((or (= v1-9 'endlessfall) (= v1-9 'instant-death)))
      ((begin
         (target-timed-invulnerable (-> arg0 invinc-time) self)
         (cpad-set-buzz! (-> *cpad-list* cpads 0) 0 255 (seconds 0.5))
         (let ((v1-13 (-> arg0 angle))) (= v1-13 'up)))
       ;;(sound-play "hit-up")
       )
      (else
        (when (>= (-> self fact health) 1.0) (sound-play "hev_beep")))))
  (case (-> arg0 mode)
    (('burn 'burnup)
     ;; og:preserve-this
     (if (not (handle->process (-> self burn-proc)))
       (set! (-> self burn-proc)
             (ppointer->handle (process-spawn-function process process-drawable-burn-effect (seconds 4) :to self)))))
    (('tar) (sound-play "get-burned")))
  0
  (none))

(defbehavior target-hl-attacked target ((arg0 symbol) (arg1 attack-info) (arg2 process) (arg3 touching-shapes-entry) (arg4 (state symbol attack-info target)))
  (when (and (not (logtest? (-> self state-flags) (state-flags being-attacked))) (target-should-take-lava-damage? arg1))
    (cond
      ((or (logtest? (-> self state-flags) (state-flags invulnerable timed-invulnerable invuln-powerup))
           (and (logtest? (-> arg1 mask) (attack-mask mode))
                (= (-> arg1 mode) 'darkeco)
                (and (and (= (-> self fact eco-type) (pickup-type eco-red)) (>= (-> self fact eco-level) 1.0))
                     (logtest? (state-flags dangerous flop-hit-ground) (-> self state-flags)))))
       (case arg0
         (('attack-or-shove))
         (('attack-invinc) (set! arg0 'attack))
         (else (return #f))))
      (else
       (case arg0
         (('attack-or-shove 'attack-invinc) (set! arg0 'attack)))))
    (mem-copy! (the-as pointer (-> self attack-info-rec)) (the-as pointer arg1) 104)
    (when arg3
      (let ((a1-2 (prims-touching? arg3 (-> self control) (the-as uint -1))))
        (when a1-2
          (get-intersect-point (-> self attack-info-rec intersection) a1-2 (-> self control) arg3)
          (logior! (-> self attack-info-rec mask) (attack-mask intersection)))))
    (set! (-> self attack-info-rec prev-state) (-> self state))
    (logior! (-> self attack-info-rec mask) (attack-mask atki13))
    (when (not (logtest? (-> self attack-info-rec mask) (attack-mask attacker)))
      (set! (-> self attack-info-rec attacker) (process->handle arg2))
      (logior! (-> self attack-info-rec mask) (attack-mask attacker)))
    (cond
      ((and (logtest? (-> self attack-info-rec mask) (attack-mask mode))
            (and (= (-> self attack-info-rec mode) 'damage) (not (and (= (-> self game mode) 'play) (>= 1.0 (-> self fact health))))))
       (pickup-collectable! (-> self fact) (pickup-type eco-green) (- (-> *FACT-bank* health-single-inc)) (the-as handle #f))

       (target-timed-invulnerable (if (logtest? (-> self attack-info-rec mask) (attack-mask invinc-time))
                                    (-> self attack-info-rec invinc-time)
                                    (-> *TARGET-bank* hit-invulnerable-timeout))
                                  self)
       (cpad-set-buzz! (-> *cpad-list* cpads 0) 0 255 (seconds 0.5))
       #t)
      (else
       (logior! (-> self state-flags) (state-flags being-attacked))
       (if (and (= (-> self game mode) 'play) (and (>= 1.0 (-> self fact health)) (= arg0 'attack)))
         (logior! (-> self state-flags) (state-flags dying)))
       (go arg4 arg0 (-> self attack-info-rec))))))

(defbehavior target-hl-generic-event-handler target ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (local-vars (v0-0 object))
  (case arg2
    (('get-pickup)
     (when (not (logtest? (-> self state-flags) (state-flags dying)))
       (let ((s4-0 (-> arg3 param 0))
             (f28-0 (the-as float (-> arg3 param 1))))
         (if (!= (pickup-collectable! (-> self fact) (the-as pickup-type s4-0) (the-as float 0.0) (the-as handle #f))
                 (pickup-collectable! (-> self fact) (the-as pickup-type s4-0) f28-0 (process->handle arg0)))
           #t
           'full))))
    (('reset-pickup) (reset! (-> self fact) (the-as symbol (-> arg3 param 0))))
    (('reset-collide)
     (cond
       ((-> self control unknown-symbol00)
        (target-collide-set! (-> self control unknown-symbol00) (-> self control unknown-float90)))
       ((-> self control unknown-symbol30) (target-danger-set! (-> self control unknown-symbol30) #f))))
    (('level-deactivate) #f)
    (('level-enter)
     (let ((v1-21 (level-get *level* (the-as symbol (-> arg3 param 0)))))
       (when v1-21
         (let ((s5-1 (-> v1-21 info)))
           (let ((v1-22 (-> s5-1 buzzer)))
             (if (zero? v1-22)
               (set! (-> self fact buzzer) 0.0)
               (set! (-> self fact buzzer)
                     (pickup-collectable! (-> self fact) (pickup-type buzzer) (the float (logior -65536 v1-22)) (the-as handle #f)))))
           (if (and (zero? (-> *game-info* enter-level-time (-> s5-1 index))) (>= (-> *level-task-data-remap* length) (-> s5-1 index)))
             (set-time! (-> *game-info* enter-level-time (-> *level-task-data-remap* (+ (-> s5-1 index) -1))))))
         (send-event (ppointer->process (-> *hud-parts* buzzers)) 'sync)
         (format #t "GAMEPLAY: enter ~A~%" (-> arg3 param 0)))))
    (('get-attack-count)
     (set! v0-0 (+ (-> self control unknown-dword51) (-> arg3 param 0)))
     (set! (-> self control unknown-dword51) (the-as int v0-0))
     v0-0)
    (('continue) (go target-continue (the-as continue-point (-> arg3 param 0))))
    (('query)
     (case (-> arg3 param 0)
       (('powerup) (and (= (-> self fact eco-type) (-> arg3 param 1)) (< 0.0 (-> self fact eco-level))))
       (('pickup)
        (pickup-collectable! (-> self fact) (the-as pickup-type (-> arg3 param 1)) (the-as float 0.0) (the-as handle #f)))
       (('ground-height) (target-height-above-ground))))
    (('trans)
     (case (-> arg3 param 0)
       (('save)
        (set! (-> self alt-cam-pos quad) (-> self control trans quad))
        (logior! (-> self state-flags) (state-flags has-saved-position))
        (mem-copy! (the-as pointer (-> arg3 param 1)) (the-as pointer (-> self control trans)) 48))
       (('restore)
        (logclear! (-> self state-flags) (state-flags has-saved-position))
        (let ((gp-1 (-> arg3 param 1)))
          (move-to-point! (-> self control) (the-as vector (+ gp-1 0)))
          (quaternion-copy! (-> self control quat) (the-as quaternion (+ gp-1 16))))
        (rot->dir-targ! (-> self control))
        (logior! (-> self control status) (cshape-moving-flags onsurf onground tsurf))
        (set! v0-0 (current-time))
        (set! (-> self control last-ground-time) (the-as time-frame v0-0))
        v0-0)
       (('reset)
        (set! v0-0 (logclear (-> self state-flags) (state-flags has-saved-position)))
        (set! (-> self state-flags) (the-as state-flags v0-0))
        v0-0)))
    (('effect) (target-powerup-effect (the-as symbol (-> arg3 param 0))))
    (('do-effect)
     (effect-control-method-10 (-> self skel effect) (the-as symbol (-> arg3 param 0)) (the-as float (-> arg3 param 1)) -1)
     (if (-> self sidekick)
       (effect-control-method-10 (-> self sidekick 0 skel effect)
                                 (the-as symbol (-> arg3 param 0))
                                 (the-as float (-> arg3 param 1))
                                 -1)))
    (('neck)
     (set! (-> self neck flex-blend) (the-as float (-> arg3 param 0)))
     (cond
       ((-> arg3 param 1)
        (logior! (-> self state-flags) (state-flags looking-at-enemy))
        (set! (-> self alt-neck-pos quad) (-> (the-as vector (-> arg3 param 1)) quad))
        (look-at-enemy! (-> self neck) (-> self alt-neck-pos) 'force arg0))
       (else
        (set! v0-0 (logclear (-> self state-flags) (state-flags looking-at-enemy)))
        (set! (-> self state-flags) (the-as state-flags v0-0))
        v0-0)))
    (('sidekick)
     (cond
       ((and (-> arg3 param 0) (not (-> self sidekick)))
        (let ((gp-2 (get-process *default-dead-pool* sidekick #x4000)))
          (set! v0-0
                (when gp-2
                  (let ((t9-21 (method-of-type sidekick activate)))
                    (t9-21 (the-as sidekick gp-2) self 'sidekick (the-as pointer #x70004000)))
                  (run-now-in-process gp-2 init-sidekick)
                  (-> gp-2 ppointer))))
        (set! (-> self sidekick) (the-as (pointer sidekick) v0-0))
        v0-0)
       ((and (not (-> arg3 param 0)) (-> self sidekick))
        (deactivate (-> self sidekick 0))
        (set! (-> self sidekick) (the-as (pointer sidekick) #f))
        #f)))
    (('blend-shape)
     (if (-> arg3 param 0)
       (logior! (-> self skel status) (janim-status blerc))
       (logclear! (-> self skel status) (janim-status blerc)))
     (let ((v1-105 (new 'stack-no-clear 'event-message-block)))
       (set! (-> v1-105 from) arg0)
       (set! (-> v1-105 num-params) arg1)
       (set! (-> v1-105 message) arg2)
       (set! (-> v1-105 param 0) (-> arg3 param 0))
       (set! (-> v1-105 param 1) (-> arg3 param 1))
       (set! (-> v1-105 param 2) (-> arg3 param 2))
       (set! (-> v1-105 param 3) (-> arg3 param 3))
       (set! (-> v1-105 param 4) (-> arg3 param 4))
       (set! (-> v1-105 param 5) (-> arg3 param 5))
       (set! (-> v1-105 param 6) (-> arg3 param 6))
       (send-event-function (ppointer->process (-> self sidekick)) v1-105)))
    (('shadow)
     (cond
       ((-> arg3 param 0)
        (let ((v1-108 (-> self draw shadow-ctrl))) (logclear! (-> v1-108 settings flags) (shadow-flags disable-draw)))
        0)
       (else (let ((v1-110 (-> self draw shadow-ctrl))) (logior! (-> v1-110 settings flags) (shadow-flags disable-draw))) 0)))
    (('rotate-y-angle)
     (quaternion-rotate-y! (-> self control quat-targ)
                           (-> self control quat-targ)
                           (the-as float (-> arg3 param 0)))
     (if (= (-> *cpad-list* cpads (-> self control cpad number) stick0-speed) 0.0)
       (rot->dir-targ! (-> self control))))
    (('touched) (send-event arg0 'touch (-> arg3 param 0)))
    (('dry) (set! (-> self water drip-wetness) 0.0))
    (('reset-height) (set! (-> self control last-air-trans quad) (-> self control trans quad)) #f)
    (('draw)
     (if (-> arg3 param 0)
       (logclear! (-> self draw status) (draw-status skip-bones))
       (logior! (-> self draw status) (draw-status skip-bones)))
     (let ((v1-132 (new 'stack-no-clear 'event-message-block)))
       (set! (-> v1-132 from) arg0)
       (set! (-> v1-132 num-params) arg1)
       (set! (-> v1-132 message) arg2)
       (set! (-> v1-132 param 0) (-> arg3 param 0))
       (set! (-> v1-132 param 1) (-> arg3 param 1))
       (set! (-> v1-132 param 2) (-> arg3 param 2))
       (set! (-> v1-132 param 3) (-> arg3 param 3))
       (set! (-> v1-132 param 4) (-> arg3 param 4))
       (set! (-> v1-132 param 5) (-> arg3 param 5))
       (set! (-> v1-132 param 6) (-> arg3 param 6))
       (send-event-function (ppointer->process (-> self manipy)) v1-132)))
    (('no-load-wait)
     (set! v0-0 (+ (current-time) (the-as time-frame (-> arg3 param 0))))
     (set! (-> self no-load-wait) (the-as time-frame v0-0))
     v0-0)
    (('no-look-around)
     (set! (-> self no-look-around-wait) (+ (current-time) (the-as time-frame (-> arg3 param 0))))
     (if (= (-> self next-state name) 'target-look-around) (send-event self 'end-mode)))
    (('change-state)
     (go (the-as (state object object object object target) (-> arg3 param 0))
         (-> arg3 param 1)
         (-> arg3 param 2)
         (-> arg3 param 3)
         (-> arg3 param 4)))))

(defstate target-hl-clone-anim (target)
  :event
    (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
      (if (and (= message 'trans) (= (-> block param 0) 'restore)) (set! (-> self control temp-flop-end-checks) (the-as uint #f)))
      ((-> target-hl-grab event) proc argc message block))
  :enter
    (behavior ((arg0 handle))
      (set! (-> self control pole) arg0)
      (set! (-> self control last-transv2 quad) (-> self control trans quad))
      (set! (-> self control temp-flop-end-checks) (the-as uint #t))
      (quaternion-copy! (the-as quaternion (-> self control last-transv3)) (-> self control quat))
      (logior! (-> self state-flags) (state-flags grabbed))
      (vector-reset! (-> self control transv))
      (set! (-> self neck flex-blend) 0.0)
      (send-event (ppointer->process (-> self sidekick)) 'shadow #t))
  :exit
    (behavior ()
      (send-event (ppointer->process (-> self sidekick)) 'matrix 'normal)
      (send-event (ppointer->process (-> self sidekick)) 'shadow #t)
      (let ((gp-0 (joint-node eichar-lod0-jg main))
            (a1-2 (&-> (-> self control) unknown-qword00)))
        (cond
          ((not (-> self control temp-spool)))
          ((not (logtest? (-> self draw status) (draw-status hidden)))
           (move-to-point! (-> self control) (the-as vector a1-2))
           (matrix->quaternion (-> self control quat-targ) (-> gp-0 bone transform))
           (quaternion-copy! (-> self control quat) (-> self control quat-targ))
           (move-to-ground (-> self control)
                           (the-as float 4096.0)
                           (the-as float 40960.0)
                           #t
                           (-> self control root-prim collide-with))
           (when (logtest? (-> self control status) (cshape-moving-flags on-water))
             (let ((a1-6 (new-stack-vector0)))
               (set! (-> a1-6 x) (-> self control trans x))
               (set! (-> a1-6 y) (-> self water height))
               (set! (-> a1-6 z) (-> self control trans z))
               (set! (-> a1-6 w) 1.0)
               (move-to-point! (-> self control) a1-6))))
          (else
           (format 0 "ERROR: <ASG>: camera used backup position~%")
           (move-to-point! (-> self control) (-> self control last-transv2))
           (quaternion-copy! (-> self control quat) (the-as quaternion (-> self control last-transv3))))))
      (rot->dir-targ! (-> self control))
      (logior! (-> self control status) (cshape-moving-flags onsurf onground tsurf))
      (set-time! (-> self control last-ground-time))
      (ja-channel-set! 0)
      (ja-post)
      (target-exit))
  :code
    (behavior ((arg0 handle))
      (clone-anim arg0 (the-as int (-> self draw origin-joint-index)) #t "")
      (go target-hl-movement-ground))
  :post target-no-ja-move-post)

(defstate target-hl-grab (target)
  :event
    (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
      (cond
        ((and (= message 'query) (= (-> block param 0) 'mode)) (-> self state name))
        (else
         (case message
           (('end-mode) (go target-hl-movement-ground))
           (('play-anim)
            (let ((v0-0 (the-as object (-> block param 0)))) (set! (-> self control temp-flop-end-checks) (the-as uint v0-0)) v0-0))
           (('clone-anim) (go target-hl-clone-anim (process->handle (the-as process (-> block param 0)))))
           (('change-mode)
            (case (-> block param 0)
              (('final-door)
               (go target-final-door
                   (the-as basic (process->handle (the-as process (-> block param 1))))
                   (process->handle (the-as process (-> block param 2)))))))
           (else (target-hl-generic-event-handler proc argc message block))))))
  :enter
    (behavior ()
      (set! (-> self control cur-surf) *grab-mods*)
      (set! (-> self neck flex-blend) 0.0)
      (logior! (-> self state-flags) (state-flags invulnerable grabbed))
      (set! (-> self control temp-flop-end-checks) (the-as uint 'stance))
      (pc-set-fog-intensity 1.0)
      (set! *should-show-swim-screen?* #f)      
      )
  :exit
    (behavior ()
      (logclear! (-> self state-flags) (state-flags invulnerable))
      (target-exit)
      )
  :code
    (behavior ()
      (set-forward-vel (the-as float 0.0))
      (let ((gp-0 0))
        (while (not (logtest? (-> self control status) (cshape-moving-flags onsurf)))
          ;;(target-falling-anim-trans)
          (+! gp-0 (- (current-time) (-> *display* old-base-frame-counter)))
          (suspend))
        (if (or (> gp-0 0)
                (let ((v1-11 (ja-group)))
                  (or (= v1-11 eichar-jump-ja)
                      (= v1-11 eichar-jump-loop-ja)
                      (= v1-11 eichar-launch-jump-ja)
                      (= v1-11 eichar-launch-jump-loop-ja)
                      (= v1-11 eichar-duck-high-jump-ja))))
          (target-hit-ground-anim #f))
          )
      (-> self control temp-spool)
      (loop
        (let ((gp-1 (-> self control temp-spool)))
          (case gp-1
            (('stance)
             (cond
               ((or (and (ja-group? eichar-walk-ja) (< 0.5 (-> self skel root-channel 6 frame-interp)))
                    (let ((v1-32 (ja-group)))
                      (or (= v1-32 eichar-run-squash-ja)
                          (= v1-32 eichar-run-squash-weak-ja)
                          (= v1-32 eichar-attack-from-stance-run-end-ja)
                          (= v1-32 eichar-attack-from-stance-run-alt-end-ja))))
                (ja-channel-push! 1 (seconds 0.15))
                (ja-no-eval :group! eichar-run-to-stance-loop-ja :num! (seek!) :frame-num 0.0)
                (until (ja-done? 0)
                  (suspend)
                  (ja :num! (seek!)))
                (ja-no-eval :group! eichar-run-to-stance-ja :num! (seek!) :frame-num 0.0)
                (until (ja-done? 0)
                  (suspend)
                  (ja :num! (seek!)))
                (ja-channel-push! 1 (seconds 0.15)))
               ((let ((v1-87 (ja-group)))
                  (and (or (= v1-87 eichar-jump-short-land-ja) (= v1-87 eichar-jump-land-ja)) (not (ja-max? 0))))
                (ja-no-eval :num! (seek!))
                (while (not (ja-done? 0))
                  (suspend)
                  (ja-eval))
                (ja-channel-push! 1 (seconds 0.075)))
               ((not (and (ja-group? eichar-stance-loop-ja) (= (ja-group-size) 1))) (ja-channel-push! 1 (seconds 0.075))))
             (loop
               (ja-no-eval :group! eichar-stance-loop-ja :num! (seek!) :frame-num 0.0)
               (until (ja-done? 0)
                 (if (!= gp-1 (-> self control temp-spool)) (goto cfg-94))
                 (suspend)
                 (ja :num! (seek!)))))
            (('shock-in)
             (ja-channel-push! 1 (seconds 0.2))
             (ja-no-eval :group! eichar-shocked-ja :num! (seek! (ja-aframe (the-as float 18.0) 0)) :frame-num 0.0)
             (until (ja-done? 0)
               (if (!= gp-1 (-> self control temp-spool)) (goto cfg-94))
               (suspend)
               (ja :num! (seek! (ja-aframe (the-as float 18.0) 0))))
             (loop
               (if (!= gp-1 (-> self control temp-spool)) (goto cfg-94))
               (suspend)))
            (('shock-out)
             (if (not (ja-group? eichar-shocked-ja)) (ja-channel-push! 1 (seconds 0.2)))
             (ja-no-eval :group! eichar-shocked-ja :num! (seek!) :frame-num (ja-aframe (the-as float 18.0) 0))
             (until (ja-done? 0)
               (if (!= gp-1 (-> self control temp-spool)) (goto cfg-94))
               (suspend)
               (ja :num! (seek!)))
             (set! (-> self control temp-flop-end-checks) (the-as uint 'stance)))))
        (label cfg-94)))
  :post
    (behavior ()
      (if (logtest? (-> self control status) (cshape-moving-flags onsurf))
        (set! (-> self control transv quad) (the-as uint128 0)))
      (target-hl-no-stick-post)))

(defstate target-hl-play-anim (target)
  :event target-generic-event-handler
  :enter
    (behavior ((arg0 string) (arg1 handle))
      (set! (-> self control pole) arg1)
      (move-to-ground (-> self control)
                      (the-as float 40960.0)
                      (the-as float 40960.0)
                      #f
                      (-> self control root-prim collide-with))
      (logior! (-> self state-flags) (state-flags grabbed))
      (set! (-> self neck flex-blend) 0.0))
  :exit
    (behavior ()
      (send-event (handle->process (-> self control pole)) 'end-mode)
      (target-exit))
  :code
    (behavior ((arg0 string) (arg1 handle))
      (let ((gp-0 (the-as art-joint-anim (lookup-art (-> self draw art-group) arg0 art-joint-anim))))
        (when gp-0
          (send-event (ppointer->process (-> self sidekick)) 'matrix 'play-anim)
          (ja-channel-set! 1)
          (ja-no-eval :group! gp-0 :num! (seek!) :frame-num 0.0)
          (until (ja-done? 0)
            (suspend)
            (ja :num! (seek!)))
          (send-event (ppointer->process (-> self sidekick)) 'matrix 'normal)))
      (go target-hl-movement-ground))
  :post target-hl-no-stick-post)

(defbehavior target-hl-standard-event-handler target ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('attack 'attack-or-shove 'attack-invinc)
     (target-hl-attacked arg2
                      (the-as attack-info (-> arg3 param 1))
                      arg0
                      (the-as touching-shapes-entry (-> arg3 param 0))
                      target-hl-hit))
    (('attack-hl)
     (target-hl-explosion-handler arg2
                      (the-as attack-info (-> arg3 param 1))
                      arg0
                      (the-as touching-shapes-entry (-> arg3 param 0))
                      target-hl-hit
                      arg3))
    (('shove)
     (when (!= (-> self next-state name) 'target-hl-hit)
       (mem-copy! (the-as pointer (-> self attack-info-rec)) (the-as pointer (-> arg3 param 1)) 104)
       (when (not (logtest? (-> self attack-info-rec mask) (attack-mask attacker)))
         (set! (-> self attack-info-rec attacker) (process->handle arg0))
         (logior! (-> self attack-info-rec mask) (attack-mask attacker)))
       (go target-hl-hit 'shove (-> self attack-info-rec))))
    (('launch) (mem-copy! (&-> (-> self control) unknown-pointer00) (the-as pointer arg3) 72) #t)
    #|
    (('loading)
     (if (not (or (and (logtest? (-> self control cur-surf flags) (surface-flags jump))
                       (not (logtest? (-> self control status) (cshape-moving-flags onsurf))))
                  (or (logtest? (-> self water flags) (water-flags wt09))
                      (logtest? (-> self state-flags) (state-flags dangerous sf02 being-attacked grabbed first-person-mode dying))
                      (logtest? (-> self control root-prim prim-core action)
                                (collide-action edgegrab-cam swingpole-active racer snowball tube flut))
                      (>= (-> self no-load-wait) (current-time)))))
       (go target-load-wait)))|#
    (('change-mode)
     (case (-> arg3 param 0)
       (('grab) (go target-hl-grab))
       ;;(('look-around) (go target-look-around))
       (('billy) (go target-hl-billy-game))
       ;;(('falling) (go target-falling #f))
       (('racing) (go target-hl-racing-start (process->handle (the-as process (-> arg3 param 1)))))
       (('flut) (go target-flut-start (process->handle (the-as process (-> arg3 param 1)))))
       ;;(('snowball) (go target-snowball-start (process->handle (the-as process (-> arg3 param 1)))))
       (('tube)
       #|
        (if (and (logtest? (-> self control status) (cshape-moving-flags onsurf))
                 (not (logtest? (-> self water flags) (water-flags wt09))))
          (go target-tube-start (process->handle (the-as process (-> arg3 param 1)))))|#)
       (('periscope)
        (if (logtest? (-> self control status) (cshape-moving-flags onsurf))
          (go target-hl-periscope (process->handle (the-as process (-> arg3 param 1))))))
       (('fishing) (go target-hl-fishing (process->handle (the-as process (-> arg3 param 1)))))
       (('final-door)
        (go target-final-door
            (the-as basic (process->handle (the-as process (-> arg3 param 1))))
            (process->handle (the-as process (-> arg3 param 2)))))))
    (('play-anim) (go target-hl-play-anim (the-as string (-> arg3 param 0)) (the-as handle arg1)))
    (('clone-anim) (go target-hl-clone-anim (process->handle (the-as process (-> arg3 param 0)))))
    ;;(('edge-grab) (go target-edge-grab))
    (('swim)
     (if (not (or (= (-> self control cur-surf mode) 'swim)
                  (= (-> self control cur-surf mode) 'dive)
                  (= (-> self next-state name) 'target-hit)
                  (= (-> *target* state name) 'target-hl-movement-swim)))
       (go target-hl-movement-swim)))
    (('pole-grab)
     (if (not (logtest? (-> self control root-prim prim-core action) (collide-action swingpole-active)))
       (go target-pole-cycle (process->handle (the-as process (-> arg3 param 0))))))
    (('tongue) (target-apply-tongue (the-as vector (-> arg3 param 0))))
    (else (target-hl-generic-event-handler arg0 arg1 arg2 arg3))
    ))

(defstate target-hl-hit (target)
  :enter
  ;; this was added so we instantly die when we lose all health
  (behavior ()
    (when (and (= (-> self game mode) 'play) (<= (-> self fact health) 1.0))
      (pickup-collectable! (-> self fact) (pickup-type eco-green) (- (-> *FACT-bank* health-single-inc)) (the-as handle #f))
      (go target-hl-death (-> self attack-info mode)))
  )
  :event target-hl-standard-event-handler
  :exit
    (behavior ()
      (let ((gp-0 (new-stack-vector0))
            (f30-0 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
        0.0
        (vector-! gp-0 (-> self control transv) (vector-float*! gp-0 (-> self control dynam gravity-normal) f30-0))
        (let* ((f1-0 (vector-length gp-0))
               (f0-3 f1-0))
          (if (< 40960.0 f1-0) (set! f1-0 40960.0))
          (vector+! (-> self control transv)
                    (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f30-0)
                    (vector-float*! gp-0 gp-0 (/ f1-0 f0-3)))))
      (if (!= (-> self next-state name) 'target-hl-death) (logclear! (-> self state-flags) (state-flags being-attacked dying)))
      (target-hl-exit))
  :trans
    (behavior ()
      (when (= *cheat-mode* 'debug)
        (when (and (not *pause-lock*) (cpad-hold? (-> self control cpad number) r2))
          (pickup-collectable! (-> self fact) (pickup-type eco-green) (the-as float 1.0) (the-as handle #f))
          (go target-hl-movement-ground))))
  :code
    (behavior ((arg0 symbol) (arg1 attack-info))
      (logclear! (-> self water flags) (water-flags wt16))
      (set-time! (-> self state-time))
      (let ((gp-0 (-> self attack-info)))
        (let ((s5-0 (new 'stack-no-clear 'vector)))
          (let ((v1-4 gp-0))
            (set! (-> v1-4 attacker) (the-as handle #f))
            (set! (-> v1-4 mode) 'generic)
            (set! (-> v1-4 shove-back) 6144.0)
            (set! (-> v1-4 shove-up) 4915.2)
            (set! (-> v1-4 angle) #f)
            (set! (-> v1-4 trans quad) (-> self control trans quad))
            (set! (-> v1-4 control) 0.0)
            (set! (-> v1-4 invinc-time) (-> *TARGET-bank* hit-invulnerable-timeout)))
          (case arg0
            (('shove)
             (let ((v1-7 gp-0))
               (set! (-> v1-7 shove-back) (-> *TARGET-bank* smack-surface-dist))
               (set! (-> v1-7 shove-up) (-> *TARGET-bank* smack-surface-height))
               (set! (-> v1-7 angle) 'shove))))
          (combine! gp-0 arg1)
          (when (not (logtest? (-> gp-0 mask) (attack-mask vector)))
            (vector-z-quaternion! (-> gp-0 vector) (-> self control quat-targ))
            (vector-xz-normalize! (-> gp-0 vector) (- (fabs (-> gp-0 shove-back))))
            (set! (-> gp-0 vector y) (-> gp-0 shove-up)))
          (set! (-> s5-0 quad) (-> gp-0 vector quad))
          (let ((f0-10 (vector-dot (vector-normalize-copy! (new 'stack-no-clear 'vector) s5-0 (the-as float 1.0))
                                   (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> self control quat-targ)))))
            (if (not (-> self attack-info angle)) (set! (-> self attack-info angle) (if (>= 0.0 f0-10) 'front 'back))))
          (cond
            ((= arg0 'attack)
             (logior! (-> self state-flags) (state-flags being-attacked))
             (set-time! (-> self game hit-time))
             (case (-> gp-0 mode)
               (('endlessfall)
                (cond
                  ((= (-> self game mode) 'debug)
                   (let ((s4-1 (new-stack-vector0)))
                     (set! (-> s4-1 quad) (-> self control last-known-safe-ground quad))
                     (ja-channel-set! 0)
                     (let ((s3-1 (current-time))) (until (time-elapsed? s3-1 (seconds 1)) (suspend)))
                     (move-to-point! (-> self control) s4-1))
                   (set! (-> (&-> (-> self control) unknown-qword00) 0) (-> self control trans quad))
                   (send-event *camera* 'teleport)
                   (go target-hl-movement-ground))
                  (else
                   (pickup-collectable! (-> self fact) (pickup-type eco-green) (the-as float -1000.0) (the-as handle #f))
                   (go target-hl-death (-> gp-0 mode)))))
               (('drown-death 'sharkey 'lava 'dark-eco-pool 'ogreboss-super-boulder 'melt 'instant-death)
                (pickup-collectable! (-> self fact) (pickup-type eco-green) (the-as float -1000.0) (the-as handle #f))
                (if (= (-> self game mode) 'play) (go target-hl-death (-> gp-0 mode))))
               (('death) (pickup-collectable! (-> self fact) (pickup-type eco-green) (the-as float -1000.0) (the-as handle #f)))
               (('plant-boss)
                (pickup-collectable! (-> self fact) (pickup-type eco-green) (- (-> *FACT-bank* health-single-inc)) (the-as handle #f))
                (if (and (= (-> self game mode) 'play) (>= 0.0 (-> self fact health))) (go target-hl-death (-> gp-0 mode))))
               (else
                (pickup-collectable! (-> self fact) (pickup-type eco-green) (- (-> *FACT-bank* health-single-inc)) (the-as handle #f))))
             (target-hl-hit-effect gp-0))
            (else
             (case (-> gp-0 mode)
               (('burn 'burnup) (sound-play "get-burned")))))
          (set! (-> self control cur-surf) *smack-mods*)
          (target-hit-setup-anim gp-0)
          (target-hit-move gp-0 (target-hit-orient gp-0 s5-0) target-falling-anim-trans (the-as float 1.0))
          )
          (when (= (-> self fact health) 1.0) (sound-play "health_critical"))
        (if (and (= (-> self game mode) 'play) (>= 0.0 (-> self fact health))) (go target-hl-death (-> gp-0 mode)))
        (go target-hl-hit-ground #f)
        )
      )
  :post 
  (behavior ()
    (target-post)
    ;;(set! (-> self draw status) (draw-status hidden))
  ))

(defbehavior target-hl-bonk-event-handler target ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (let ((s4-0 (new 'stack-no-clear 'vector)))
    (cond
      ((and (= arg2 'touched)
            ((method-of-type touching-shapes-entry prims-touching?)
             (the-as touching-shapes-entry (-> arg3 param 0))
             (-> self control)
             (the-as uint 6))
            (< (* 16384.0 (-> *display* time-adjust-ratio))
               (vector-dot (-> self control dynam gravity-normal)
                           (vector-! (new 'stack-no-clear 'vector) (-> self control transv) (-> self control last-transv))))
            (begin
              (vector-normalize! (vector-! s4-0 (the-as vector (-> self control body-spheres 0 prim-core)) (-> self control best-cshape-intersect))
                                 (the-as float 1.0))
              (< 0.01 (-> s4-0 y))))
       (if (< 0.75 (-> s4-0 y))
         (send-event arg0
                     'bonk
                     (-> arg3 param 0)
                     (fmax (-> self control ground-impact-vel)
                           (- (vector-dot (-> self control transv) (-> self control dynam gravity-normal))))))
       (let ((f0-7 (vector-dot (-> self control dynam gravity-normal)
                               (vector-! (new 'stack-no-clear 'vector) (-> self control racer-cushion-targ1) (-> self control trans)))))
         (when (< (-> *TARGET-bank* fall-far) f0-7)
           (when (and (target-send-attack arg0
                                          (the-as uint 'bonk)
                                          (the-as touching-shapes-entry (-> arg3 param 0))
                                          (-> self control unknown-dword50)
                                          (-> self control unknown-dword51))
                      (not (logtest? (-> self state-flags) (state-flags being-attacked dying))))
             (set! (-> self control last-air-trans quad) (-> self control trans quad))
             (target-timed-invulnerable (seconds 0.1) self)
             (go target-hl-jump (-> *TARGET-bank* jump-height-min) (-> *TARGET-bank* jump-height-max) (the-as surface #f)))))
       #f)
      ((= arg2 'jump)
       (sound-play "jump-long")
       (go target-hl-jump (the-as float (-> arg3 param 0)) (the-as float (-> arg3 param 1)) (the-as surface (-> arg3 param 2)))
       
       )
       )))

(defbehavior target-hl-walk-event-handler target ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (let ((v0-0 (target-hl-bonk-event-handler arg0 arg1 arg2 arg3)))
    (cond
      (v0-0 (empty) v0-0)
      (else (target-hl-standard-event-handler arg0 arg1 arg2 arg3)))))

(defbehavior target-hl-jump-event-handler target ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (if (and (= arg2 'swim) (< 0.0 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))) (return #f))
  (let ((v0-0 (target-hl-bonk-event-handler arg0 arg1 arg2 arg3)))
    (cond
      (v0-0 (empty) v0-0)
      (else (target-hl-standard-event-handler arg0 arg1 arg2 arg3)))))
