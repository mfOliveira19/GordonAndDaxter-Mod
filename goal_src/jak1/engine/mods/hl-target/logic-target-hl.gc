(in-package goal)

;; Lots of global stuff, it could be improved by putting it in the target structure but i did not want to mess too much with it

;; movement constants
(defconstant jump-speed 35000.0)
(defconstant gravity-factor 0.55)
(defconstant hl-max-speed   50650.0)
(defconstant hl-max-speed-blue-eco 70650.0)
(defconstant hl-max-speed-swim 36325.0)
(defconstant hl-max-speed-swim-blue-eco 50325.0)
(defconstant hl-accel       12.0)
(defconstant hl-accel-ice    2.0)
(defconstant hl-air-accel   190.0)
(defconstant hl-friction    4.0)
(defconstant hl-friction-ice 1.0)
(defconstant hl-stopspeed   20080.0)
(defconstant fall-damage-threshold 30000.0)
(defconstant hl-air-wishspeed 5500.0)
(define *foot-left* #f)
(define *last-step-frame* 0)
(define *last-step-time* 0)
(define *last-swim-enter-time* 0)
(define *fall-start-height* 0.0)
(define *falling* #f)
(define *should-take-fall-damage* #f)
(define *entered-swim?* #f)
(define *should-show-swim-screen?* #f)
;; Duck stuff
(define *ducked?* #f)
(define *ground-duck-started* #f)
(define *ground-duck-accum* 0.0)
(define *ground-unduck-started* #f)
(define *ground-unduck-accum* 0.0)
(defconstant duck-camera-depth -4500.0)
(defconstant duck-hop 2500.0)
;; global camera duck offset

(define *duck-camera-offset* 0.0)
(define *can-apply-air-duck-offset* #t)
(define *viewmodel-bob-phase* 0.0)
(define *viewmodel-bob-current-z* 0.0)
(define *viewmodel-rot-x* 0.0)
(defconstant viewmodel-bob-speed 1300.0)
(defconstant viewmodel-bob-amp-base 1.0)
(defconstant viewmodel-bob-return-rate 0.12)

;; --- Camera view bob control ---
(define *view-bob-x* 0.0)
(define *view-bob-y* 0.0)
(define *view-bob-phase* 0.0)
(define *view-bob-current-x* 0.0)
(define *view-bob-current-y* 0.0)
(defconstant view-bob-speed 0.02)
(defconstant view-bob-vert-amp-base 250.0)
(defconstant view-bob-horiz-amp-base 200.0)
(defconstant view-bob-return-rate 0.1)

(define *target-duck-enter-time* 0)
(define *target-enable-long-jump* #f)

(defenum collide-set
  (normal 0)
  (duck-ground 1)
  (duck-air 2))

(define *target-current-collide-set* (collide-set normal))

(defun target-has-eco-type? ((type pickup-type))
  (and (= (-> *target* fact eco-type) type) (> (-> *target* fact eco-level) 0.0)))

(defbehavior target-hl-compute-slopes target ((arg0 vector))
  (let ((gp-0 (new-stack-vector0)))
    (let ((a1-0 (new-stack-vector0))
          (s5-0 (new 'stack-no-clear 'matrix)))
      
      ;; get upward axis without pitch
      (set! (-> a1-0 quad) (-> self control unknown-matrix01 vector 2 quad))
      (forward-up-nopitch->inv-matrix s5-0 a1-0 arg0)

      ;; -------------------------------
      ;; COMPUTE FORWARD SLOPE (X)
      ;; -------------------------------
      (set-vector! gp-0 0.0 0.0 1.0 1.0)
      (vector-matrix*! gp-0 gp-0 s5-0)
      (let ((slope-x (- (vector-dot (-> self control surface-normal) gp-0))))

        ;; ----------------------------------------
        ;; HL-style "step forgiveness" / slope easing
        ;; ----------------------------------------
        (let* ((vz (-> self control ltransv y))     ;; vertical velocity
               (on-ground (logtest? (-> self control status)
                                    (cshape-moving-flags onground)))
               (ease
                 ;; Bigger ease when airborne or moving upward
                 (cond
                   ((not on-ground) 10.45)         ;; jumping / edge = lots of forgiveness
                   ((< vz -100.0) 0.25)         ;; moving upward
                   (else               0.0))))

          ;; reduce steepness = slope * (1 - ease)
          (set! slope-x (* slope-x (- 1.0 ease))))

        (set! (-> self control surface-slope-x) 0.0)
        (set! (-> self control tween-input)
              (- (vector-dot (-> self control local-normal) gp-0))))


      ;; -------------------------------
      ;; COMPUTE SIDE SLOPE (Z)
      ;; -------------------------------
      (set-vector! gp-0 1.0 0.0 0.0 1.0)
      (vector-matrix*! gp-0 gp-0 s5-0)
      (let ((slope-z (- (vector-dot (-> self control surface-normal) gp-0))))

        ;; same slope easing rules for sideways stepping
        (let* ((vz (-> self control ltransv y))
               (on-ground (logtest? (-> self control status)
                                    (cshape-moving-flags onground)))
               (ease
                (cond
                  ((not on-ground) 10.45)
                  ((> vz 0.0)      0.25)
                  (else               0.0))))

          (set! slope-z (* slope-z (- 1.0 ease))))

        (set! (-> self control surface-slope-z) 0.0)
        (set! (-> self control tween-output)
              (- (vector-dot (-> self control local-normal) gp-0))))))
  0)

(defbehavior do-rotations2-hl target ()
  (let ((gp-0 (vector-z-quaternion! (new-stack-vector0) (-> self control dir-targ)))
        (s5-0 (if (and (or (not (logtest? (logior (-> self control status) (-> self control old-status)) (cshape-moving-flags onsurf tsurf)))
                           (not (time-elapsed? (-> self control moving-surf-touch-time) (seconds 0.5)))
                           (!= (-> self next-state name) 'target-walk)
                           (not (time-elapsed? (-> self state-time) (seconds 0.5)))
                           (not (time-elapsed? (-> self control low-coverage-touch-time) (seconds 0.5)))
                           (logtest? (-> self control new-surf flags) (surface-flags no-rotate-toward-transv))
                           (!= (-> self control force-push-speed-mod) 0.0))
                       (not (logtest? (-> self control new-surf flags) (surface-flags always-rotate-toward-transv))))
                (-> self control unknown-vector20)
                (-> self control transv))))
    (let* ((s3-0 (-> self control normal-targ))
           (s4-0 (forward-up-nopitch->quaternion (new-stack-quaternion0) gp-0 s3-0))
           (s3-1 (forward-up-nopitch->quaternion (new-stack-quaternion0) s5-0 s3-0))
           (f0-2 (acos (vector-dot gp-0 s5-0)))
           (f1-2 (* (-> self control new-surf turnvv) (seconds-per-frame))))
      (quaternion-slerp! (-> self control dir-targ)
                         s4-0
                         s3-1
                         (cond
                           ((>= 0.0 (-> self control turn-vec-len)) 0.0)
                           ((< f0-2 f1-2) 1.0)
                           (else (/ f1-2 f0-2)))))
    (add-debug-vector *display-target-marks*
                      (bucket-id debug-no-zbuf)
                      (-> self control trans)
                      gp-0
                      (meters 2)
                      (new 'static 'rgba :r #xff :g #xff :b #xff :a #x80))
    (add-debug-vector *display-target-marks*
                      (bucket-id debug-no-zbuf)
                      (-> self control trans)
                      s5-0
                      (meters 2)
                      (new 'static 'rgba :r #xff :a #x80)))
  (add-debug-vector *display-target-marks*
                    (bucket-id debug-no-zbuf)
                    (-> self control trans)
                    (-> self control unknown-matrix01 vector 2)
                    (meters 2)
                    (new 'static 'rgba :r #xff :b #xff :a #x80))
  (rotate-toward-orientation! (-> self control) (-> self control dir-targ) (-> self control new-surf turnv) 0.0)
  (quaternion-slerp! (-> self control quat)
                     (-> self control quat-targ)
                     (-> self control quat-base)
                     (-> self control quat-mod))
  (target-hl-compute-slopes (-> self control dynam gravity-normal))
  0
  )

(defun on-ground? ()
  ;;(logtest? (-> *target* control status) (cshape-moving-flags onground))
  (not (and (not (logtest? (-> *target* control status) (cshape-moving-flags onsurf))) 
    (time-elapsed? (-> *target* control last-ground-time) (seconds 0.06))))
)

(defbehavior update-viewmodel-bob target ()
  (let ((hvel (new 'stack-no-clear 'vector)))
    (vector-copy! hvel (-> self control ltransv))
    (set! (-> hvel y) 0.0)
    (let ((speed (vector-length hvel)))

      ;; Advance or decay bob phase
      (if (> speed 0.1)
          (set! *viewmodel-bob-phase* (+ *viewmodel-bob-phase* (* viewmodel-bob-speed (-> *display* time-adjust-ratio))))
          (set! *viewmodel-bob-phase* (* *viewmodel-bob-phase* 0.9)))

      ;; Compute speed-scaled amplitude
      (let ((amp (min 1.0 (* speed viewmodel-bob-amp-base 0.00002))))

        ;; Base bob offset
        (let ((target-offset-z
               (if (> speed 0.1)
                   (* (sin *viewmodel-bob-phase*) amp)
                   0.0)))

          ;; Get current camera pitch influence
          (let ((pitch-offset (get-camera-pitch)))
            ;; Move forward/back depending on pitch
            (set! target-offset-z (+ target-offset-z (* pitch-offset -1.0)))

            ;; Apply small viewmodel tilt
            (let ((target-rot-x (* pitch-offset 0.01)))
              (set! *viewmodel-rot-x*
                    (+ *viewmodel-rot-x*
                      (* (- target-rot-x *viewmodel-rot-x*)
                          (* viewmodel-bob-return-rate (-> *display* time-adjust-ratio)))))
              (pc-set-viewmodel-rotation-x *viewmodel-rot-x*))

          ;; Smooth Z movement
          (set! *viewmodel-bob-current-z*
                (+ *viewmodel-bob-current-z*
                  (* (- target-offset-z *viewmodel-bob-current-z*)
                      (* viewmodel-bob-return-rate (-> *display* time-adjust-ratio)))))

          ;; Send to C++ side
          (pc-set-viewmodel-offset-z *viewmodel-bob-current-z*)))))))

(defbehavior update-view-bob target ()
  (let ((hvel (new 'stack-no-clear 'vector)))
    ;; get horizontal velocity (XZ plane)
    (vector-copy! hvel (-> self control ltransv))
    (set! (-> hvel y) 0.0)
    (let ((speed (vector-length hvel)))
      
      ;; Advance or decay phase
      (if (> speed 0.1)
          (set! *view-bob-phase* (+ *view-bob-phase* 
                                    (* view-bob-speed speed (-> *display* time-adjust-ratio))))
          (set! *view-bob-phase* (* 0.9 (* *view-bob-phase* (-> *display* time-adjust-ratio)))))

      ;; Compute clamped amplitude scaling based on speed
      (let ((amp-scale (min 1.0 (* speed 0.001))))
        (let ((target-x
               (if (> speed 0.1)
                   (* (sin (* 0.5 *view-bob-phase*))
                      view-bob-horiz-amp-base amp-scale)
                   0.0))
              (target-y
               (if (> speed 0.1)
                   (* (sin *view-bob-phase*)
                      view-bob-vert-amp-base amp-scale)
                   0.0)))
          
          ;; Smooth interpolation toward target (returns to center when stopping)
          (set! *view-bob-current-x*
                (+ *view-bob-current-x*
                   (* (- target-x *view-bob-current-x*)
                      (* view-bob-return-rate (-> *display* time-adjust-ratio)))))
          (set! *view-bob-current-y*
                (+ *view-bob-current-y*
                   (* (- target-y *view-bob-current-y*)
                      (* view-bob-return-rate (-> *display* time-adjust-ratio)))))

          ;; Apply to globals (used in camera transform)
          (set! *view-bob-x* *view-bob-current-x*)
          (set! *view-bob-y* *view-bob-current-y*))))))

(defun ground-duck-fraction ()
  (min 1.0 (/ *ground-duck-accum* 0.2)))

(defun ground-unduck-fraction ()
  (- 1.0 (min 1.0 (/ *ground-unduck-accum* 0.1))))

(defun update-duck-camera-offset ()
  (cond
    ;; air duck = instant
    ((target-hl-is-in-duck?)
    duck-camera-depth)

    ;; in-duck (ground timer)
    (*ground-unduck-started*
    (* duck-camera-depth (ground-unduck-fraction)))

    ;; in-duck (ground timer)
    (*ground-duck-started*
    (* duck-camera-depth (ground-duck-fraction)))

    ;; fully ducked
    (*ducked?*
    duck-camera-depth)))

(defbehavior target-calc-camera-pos-hl target ()
  (let ((cam-pos (new 'stack-no-clear 'vector)))
    (vector-copy! cam-pos (-> self control trans))
    ;; apply crouch offset
    (set! *duck-camera-offset* (update-duck-camera-offset))
    (+! (-> cam-pos y) *duck-camera-offset*)
    ;; apply view bob offsets
    (update-view-bob)
    (update-viewmodel-bob)
    (+! (-> cam-pos x) *view-bob-x*)
    (+! (-> cam-pos y) *view-bob-y*)
    ;; set final camera pos
    (set! (-> (&-> (-> self control) unknown-qword00) 0) (-> cam-pos quad)))
  0
  (none))

(defbehavior apply-fall-status target ()
  (format 0 "FALL DAMAGE~%")
  (sound-play "pl_jumpland2")
  (sound-play "pl_pain2")
  (set! *should-take-fall-damage* #f))

(defbehavior update-fall-status target ()
  (let ((cur-y (-> self control trans y)))
    (if (on-ground?)
        ;; Player has landed
        (begin
          (when *falling*
            (let ((fall-dist (- *fall-start-height* cur-y)))
              (set! *should-take-fall-damage* (> fall-dist fall-damage-threshold))))
          (set! *falling* #f)
          (set! *fall-start-height* cur-y)
            (if *should-take-fall-damage*
              (apply-fall-status))
          )) ;; reset start height
        ;; Player is in air
        (begin
          (unless *falling*
            (set! *falling* #t)
            (set! *fall-start-height* cur-y))
          (set! *should-take-fall-damage* #f))))

(defbehavior should-do-normal-swim-step? target ()
  (let ((water-proc (handle->process (-> self water volume))))
    (if
      (or
        (string= (the-as string (-> water-proc name)) "villagea-water-1")
        (string= (the-as string (-> water-proc name)) "villagea-water-3")
        (string= (the-as string (-> water-proc name)) "villagea-water-4")
        (= (-> *target* current-level name) 'swamp)
      )
      #t
      #f)))

(defbehavior hl-play-step-sound target ()
  ;; flip foot each step
  (set! *foot-left* (not *foot-left*))
  ;; get horizontal speed
  (let ((hvel (new-stack-vector0)))
    (vector-copy! hvel (-> self control ltransv))
    (set! (-> hvel y) 0.0)

    ;; don't play if too slow
    (when (or (> (vector-length hvel) 220.0) (= (-> *target* state name) 'target-hl-movement-swim))
      ;; check if in water
      (if (logtest? (-> self water flags) (water-flags wt09))
          ;; IN WATER: play water footsteps
          (let ((rand-index (+ (rand-vu-int-range 0 1) (if *foot-left* 2 0))))
            (case rand-index
              ((0) (if (= (-> *target* state name) 'target-hl-movement-swim)
                (begin 
                  (sound-play "pl_swim1"))
                (begin 
                  (if (or (should-do-normal-swim-step?))
                    (sound-play "pl_slosh1")
                    (sound-play "pl_wade1")))
              ))
              ((1) (if (= (-> *target* state name) 'target-hl-movement-swim) 
                (begin 
                  (sound-play "pl_swim3"))
                (begin 
                  (if (should-do-normal-swim-step?)
                    (sound-play "pl_slosh3")
                    (sound-play "pl_wade3")))
              ))
              ((2) (if (= (-> *target* state name) 'target-hl-movement-swim) 
                (begin 
                  (sound-play "pl_swim2"))
                (begin 
                  (if (should-do-normal-swim-step?)
                    (sound-play "pl_slosh2")
                    (sound-play "pl_wade2")))
              ))
              ((3) (if (= (-> *target* state name) 'target-hl-movement-swim)
                (begin 
                  (sound-play "pl_swim4"))
                (begin 
                  (if (should-do-normal-swim-step?)
                    (sound-play "pl_slosh4")
                    (sound-play "pl_wade4")))
              ))
              
              ))
        ;; NOT IN WATER: normal ground footsteps
        (let ((mat (-> self control ground-pat material))
              (sound-category 'concrete)) ;; default category
          (case mat
            (((pat-material sand) (pat-material dirt) (pat-material gravel))
             (set! sound-category 'dirt))
            (((pat-material metal) (pat-material pcmetal))
             (set! sound-category 'metal))
            (((pat-material swamp))
             (set! sound-category 'slosh))
            (else
             (set! sound-category 'concrete)))
          
          ;; pick random variant for left/right foot
          (let ((rand-index (+ (rand-vu-int-range 0 1) (if *foot-left* 2 0))))
            (case sound-category
              (('concrete)
               (case rand-index
                 ((0) (sound-play "pl_step1"))
                 ((1) (sound-play "pl_step3"))
                 ((2) (sound-play "pl_step2"))
                 ((3) (sound-play "pl_step4"))))
              (('dirt)
               (case rand-index
                 ((0) (sound-play "pl_dirt1"))
                 ((1) (sound-play "pl_dirt3"))
                 ((2) (sound-play "pl_dirt2"))
                 ((3) (sound-play "pl_dirt4"))))
              (('slosh)
               (case rand-index
                 ((0) (sound-play "pl_slosh1"))
                 ((1) (sound-play "pl_slosh3"))
                 ((2) (sound-play "pl_slosh2"))
                 ((3) (sound-play "pl_slosh4"))))
              (('metal)
               (case rand-index
                 ((0) (sound-play "pl_metal1"))
                 ((1) (sound-play "pl_metal3"))
                 ((2) (sound-play "pl_metal2"))
                 ((3) (sound-play "pl_metal4")))))))))))

(defbehavior footstep-time target ()
  ;; In water
  (if (logtest? (-> self water flags) (water-flags wt09))
    (if (target-has-eco-type? (pickup-type eco-blue))
      ;; With blue eco
      (if (should-do-normal-swim-step?)
        (fsec 0.25)
        (fsec 1.0)
      )
      ;; Without blue eco
      (if (should-do-normal-swim-step?)
        (fsec 0.3)
        (fsec 1.2)
      )
    )
    (if (target-has-eco-type? (pickup-type eco-blue))
        (fsec 0.25)
        (fsec 0.3)
    )
  )
)

(defbehavior hl-update-step-sound target ()
  (let ((hvel (new-stack-vector0)))
    (vector-copy! hvel (-> self control ltransv))
    (set! (-> hvel y) 0.0)
    (let ((speed (vector-length hvel)))
      
      (when (and (on-ground?) (> speed 0.0))
        ;; HL constants
        (let ((velrun 30010.0))
          
          ;; check if enough time has passed since last footstep
          (when (time-elapsed? *last-step-time* (footstep-time))
            (when (> speed velrun)
              ;; play step sound
              (hl-play-step-sound))
            
            ;; record the time we played this step
            (set-time! *last-step-time*))))))
  (none))

(defbehavior hl-add-gravity target ()
  (let ((s5-0 (new-stack-vector0))
        (gp-0 (new-stack-vector0)))
    (compute-acc-due-to-gravity (-> self control) s5-0 (-> self control new-surf slip-factor))
    
    ;; SCALE GRAVITY
    (vector-float*! s5-0 s5-0 gravity-factor)
    (vector-matrix*! gp-0 s5-0 (-> self control unknown-matrix00))
    (vector-v++! (-> self control ltransv) gp-0))
    (when (not (on-ground?))
      (let* ((s5-1 (vector-matrix*! (new-stack-vector0) (-> self control dynam gravity-normal) (-> self control unknown-matrix00)))
            (gp-1 (new-stack-vector0))
            (f30-0 (vector-dot s5-1 (-> self control ltransv))))
        0.0
        (vector-! gp-1 (-> self control ltransv) (vector-float*! gp-1 s5-1 f30-0))
        (let* ((f0-4 (vector-length gp-1))
              (f1-0 f0-4))
          (if (< f0-4 0.00004096) (set! f0-4 0.0))
          (if (< f30-0 (- (-> self control dynam gravity-max))) (set! f30-0 (- (-> self control dynam gravity-max))))
          (vector+! (-> self control ltransv)
                    (vector-float*! (-> self control ltransv) s5-1 f30-0)
                    (vector-float*! gp-1 gp-1 (/ f0-4 f1-0)))))))

(defbehavior fully-grounded? target ((probe-val float))
  (block grounded-block
    (let ((probe (new 'stack-no-clear 'collide-using-spheres-params))
          (spheres (new 'stack-no-clear 'inline-array 'sphere 1))
          (body-r (-> *TARGET-bank* body-radius))
          (probe-drop probe-val))

      ((method-of-type sphere new) (the-as symbol (-> spheres 0)) sphere)
      (set! (-> probe spheres) spheres)
      (set! (-> probe num-spheres) (the-as uint 1))
      (set! (-> probe collide-with)
            (-> self control root-prim collide-with))
      (set! (-> probe proc) #f)
      (set! (-> probe ignore-pat)
            (new 'static 'pat-surface :noentity #x1))
      (set! (-> probe solid-only) #t)

      ;; sphere 1
      (let ((bs1 (-> self control body-spheres 1)))
        (when bs1
          (set! (-> spheres 0 quad) (-> self control trans quad))
          (+! (-> spheres 0 x) (-> bs1 local-sphere x))
          (+! (-> spheres 0 y) (-> bs1 local-sphere y) (- probe-drop))
          (+! (-> spheres 0 z) (-> bs1 local-sphere z))
          (set! (-> spheres 0 w) (* body-r 0.9))
          (when (not (fill-and-probe-using-spheres *collide-cache* probe))
            (return-from grounded-block #f))))

      ;; sphere 3
      (let ((bs3 (-> self control body-spheres 3)))
        (when bs3
          (set! (-> spheres 0 quad) (-> self control trans quad))
          (+! (-> spheres 0 x) (-> bs3 local-sphere x))
          (+! (-> spheres 0 y) (-> bs3 local-sphere y) (- probe-drop))
          (+! (-> spheres 0 z) (-> bs3 local-sphere z))
          (set! (-> spheres 0 w) (* body-r 0.9))
          (when (not (fill-and-probe-using-spheres *collide-cache* probe))
            (return-from grounded-block #f))))

      ;; sphere 4
      (let ((bs4 (-> self control body-spheres 4)))
        (when bs4
          (set! (-> spheres 0 quad) (-> self control trans quad))
          (+! (-> spheres 0 x) (-> bs4 local-sphere x))
          (+! (-> spheres 0 y) (-> bs4 local-sphere y) (- probe-drop))
          (+! (-> spheres 0 z) (-> bs4 local-sphere z))
          (set! (-> spheres 0 w) (* body-r 0.9))
          (when (not (fill-and-probe-using-spheres *collide-cache* probe))
            (return-from grounded-block #f))))

      ;; sphere 5
      (let ((bs5 (-> self control body-spheres 5)))
        (when bs5
          (set! (-> spheres 0 quad) (-> self control trans quad))
          (+! (-> spheres 0 x) (-> bs5 local-sphere x))
          (+! (-> spheres 0 y) (-> bs5 local-sphere y) (- probe-drop))
          (+! (-> spheres 0 z) (-> bs5 local-sphere z))
          (set! (-> spheres 0 w) (* body-r 0.9))
          (when (not (fill-and-probe-using-spheres *collide-cache* probe))
            (return-from grounded-block #f))))

      ;; all bottom spheres blocked - fully grounded
      #t)))

(defbehavior near-wall? target ((probe-dist float))
  (block wall-block
    (let ((probe (new 'stack-no-clear 'collide-using-spheres-params))
          (spheres (new 'stack-no-clear 'inline-array 'sphere 1))
          (body-r (-> *TARGET-bank* body-radius)))

      ((method-of-type sphere new)
       (the-as symbol (-> spheres 0)) sphere)

      (set! (-> probe spheres) spheres)
      (set! (-> probe num-spheres) (the-as uint 1))
      (set! (-> probe collide-with)
            (-> self control root-prim collide-with))
      (set! (-> probe proc) #f)
      (set! (-> probe ignore-pat)
            (new 'static 'pat-surface :noentity #x1))
      (set! (-> probe solid-only) #t)

      ;; --------------------------------------------------
      ;; +X wall
      ;; --------------------------------------------------
      (let ((bs1 (-> self control body-spheres 1)))
        (when bs1
          (set! (-> spheres 0 quad) (-> self control trans quad))
          (+! (-> spheres 0 x) (-> bs1 local-sphere x) probe-dist)
          (+! (-> spheres 0 y) (-> bs1 local-sphere y))
          (+! (-> spheres 0 z) (-> bs1 local-sphere z))
          (set! (-> spheres 0 w) (* body-r 0.9))
          (when (fill-and-probe-using-spheres *collide-cache* probe)
            (return-from wall-block #t))))

      ;; --------------------------------------------------
      ;; -X wall
      ;; --------------------------------------------------
      (let ((bs1 (-> self control body-spheres 1)))
        (when bs1
          (set! (-> spheres 0 quad) (-> self control trans quad))
          (+! (-> spheres 0 x) (-> bs1 local-sphere x) (- probe-dist))
          (+! (-> spheres 0 y) (-> bs1 local-sphere y))
          (+! (-> spheres 0 z) (-> bs1 local-sphere z))
          (set! (-> spheres 0 w) (* body-r 0.9))
          (when (fill-and-probe-using-spheres *collide-cache* probe)
            (return-from wall-block #t))))

      ;; --------------------------------------------------
      ;; +Z wall
      ;; --------------------------------------------------
      (let ((bs1 (-> self control body-spheres 1)))
        (when bs1
          (set! (-> spheres 0 quad) (-> self control trans quad))
          (+! (-> spheres 0 x) (-> bs1 local-sphere x))
          (+! (-> spheres 0 y) (-> bs1 local-sphere y))
          (+! (-> spheres 0 z) (-> bs1 local-sphere z) probe-dist)
          (set! (-> spheres 0 w) (* body-r 0.9))
          (when (fill-and-probe-using-spheres *collide-cache* probe)
            (return-from wall-block #t))))

      ;; --------------------------------------------------
      ;; -Z wall
      ;; --------------------------------------------------
      (let ((bs1 (-> self control body-spheres 1)))
        (when bs1
          (set! (-> spheres 0 quad) (-> self control trans quad))
          (+! (-> spheres 0 x) (-> bs1 local-sphere x))
          (+! (-> spheres 0 y) (-> bs1 local-sphere y))
          (+! (-> spheres 0 z) (-> bs1 local-sphere z) (- probe-dist))
          (set! (-> spheres 0 w) (* body-r 0.9))
          (when (fill-and-probe-using-spheres *collide-cache* probe)
            (return-from wall-block #t))))

      ;; no wall nearby
      #f)))

(defbehavior hl-add-thrust target ()
  (let* ((wishvel   (-> self control trans-targ))
         (curvel    (-> self control ltransv))
         (frametime (seconds-per-frame)))

    ;; preserve vertical velocity
    (let ((saved-y (-> curvel y)))
      (set! (-> wishvel y) 0.0)
      (set! (-> curvel  y) 0.0)

      ;; ----------------------
      ;; APPLY FRICTION FIRST
      ;; ----------------------
      
      (when (not (should-jump?))
        (let ((speed (vector-xz-length curvel)))
          (when (> speed 0.0)
            (let* ((control (if (< speed hl-stopspeed) hl-stopspeed speed))
             (friction

              (if (= (-> self control ground-pat material) (pat-material ice))
                           (if (fully-grounded? 512.0) hl-friction-ice (* hl-friction-ice 2))
                           (if (fully-grounded? 512.0) hl-friction (* hl-friction 2)))
                  )
                  (drop (* control friction frametime))
                  (new-speed (max 0.0 (- speed drop))))
              (if (> new-speed 0.0)
                  (vector-xz-normalize! curvel new-speed)
                  (begin
                    (set! (-> curvel x) 0.0)
                    (set! (-> curvel z) 0.0)))))))

      ;; ----------------------
      ;; APPLY ACCELERATION
      ;; ----------------------
      (let ((wishspeed (vector-xz-length wishvel)) (maxspeed (if (target-has-eco-type? (pickup-type eco-blue)) hl-max-speed-blue-eco hl-max-speed)))
        (when (> wishspeed 0.0)
          ;; normalize wish direction
          (vector-normalize! wishvel 1.0)
          ;; cap to max speed
          (when (> wishspeed maxspeed)
            (set! wishspeed maxspeed))
          ;; how much velocity is already in wish direction
          (let ((curr-speed (vector-dot curvel wishvel)))
            (let ((addspeed (- wishspeed curr-speed)) (accel (if (= (-> self control ground-pat material) (pat-material ice)) hl-accel-ice hl-accel)))
            
              (when (> addspeed 0.0)
                (let ((accelspeed (* accel frametime wishspeed)))
                  (when (> accelspeed addspeed)
                    (set! accelspeed addspeed))
                  (vector+! curvel curvel
                            (vector-float*! (new-stack-vector0) wishvel accelspeed)))))))

      ;; clamp final horizontal velocity
      (let ((speed (vector-xz-length curvel)))
        (when (> speed maxspeed)
          (vector-xz-normalize! curvel maxspeed))))

      ;; restore vertical
      (set! (-> curvel y) saved-y))))

(defbehavior hl-add-air-thrust target ()
  (let* ((curvel   (-> self control ltransv))     ;; current local velocity
         (wishvel  (-> self control trans-targ))  ;; desired direction
         (frametime (seconds-per-frame)))

    ;; preserve vertical component
    (let ((saved-y (-> curvel y)))
      (set! (-> curvel y) 0.0)
      (set! (-> wishvel y) 0.0)

      ;; normalize wishdir
      (let ((wishspeed (vector-xz-length wishvel)))
        (when (> wishspeed 0.0)
          (vector-normalize! wishvel 1.0)

          ;; clamp wishspeed like HL
          (when (> wishspeed hl-air-wishspeed)
            (set! wishspeed hl-air-wishspeed))

          ;; project current velocity onto wishdir
          (let* ((currspeed (vector-dot curvel wishvel))
                 (addspeed (- wishspeed currspeed)))
            (when (> addspeed 0.0)
              ;; HL: accelspeed = accel * wishspeed * frametime
              (let ((accelspeed (* hl-air-accel
                                   wishspeed
                                   frametime)))
                ;; don’t exceed what’s needed
                (when (> accelspeed addspeed)
                  (set! accelspeed addspeed))
                ;; apply extra velocity
                (vector+! curvel curvel
                          (vector-float*! (new-stack-vector0) wishvel accelspeed)))))))

      ;; restore vertical velocity
      (set! (-> curvel y) saved-y))))

(defbehavior hl-add-air-thrust-launcher target ()
  (let* ((curvel    (-> self control ltransv))
         (wishvel   (-> self control trans-targ))
         (frametime (seconds-per-frame))

         (air-accel     30000.0)
         (wishspeed-max 30000.0)
         (turn-boost    2.5))

    (let ((saved-y (-> curvel y)))
      (set! (-> curvel y) 0.0)
      (set! (-> wishvel y) 0.0)

      (let ((wishspeed (vector-xz-length wishvel)))
        (when (> wishspeed 0.0)
          (vector-normalize! wishvel 1.0)

          (when (> wishspeed wishspeed-max)
            (set! wishspeed wishspeed-max))
          (let* ((currspeed (vector-dot curvel wishvel))
                 (addspeed (- wishspeed currspeed)))
            (when (> addspeed 0.0)

              (let ((accelspeed (* air-accel
                                   wishspeed
                                   frametime
                                   (+ 1.0 turn-boost))))
                (when (> accelspeed addspeed)
                  (set! accelspeed addspeed))

                (vector+! curvel curvel
                          (vector-float*! (new-stack-vector0)
                                          wishvel
                                          accelspeed)))))))
      (set! (-> curvel y) saved-y))))

(defun target-hl-timed-invulnerable-off ((arg0 target))
  (logclear! (-> arg0 state-flags) (state-flags timed-invulnerable))
  (set-collide-kinds (-> arg0 control) 2 (collide-kind) (collide-kind target-attack))
  0
  (none))

(defbehavior hl-post-flag-setup target ()
  (if (logtest? (-> self control status) (cshape-moving-flags twall t-act)) (set-time! (-> self control moving-surf-touch-time)))
  (when (logtest? (-> self state-flags) (state-flags timed-invulnerable))
    (if (time-elapsed? (-> self control unknown-dword80) (-> self control unknown-dword81))
      (target-hl-timed-invulnerable-off self)))
  (set! (-> self control unknown-symbol40) #f)
  0
  (none))

(defbehavior target-hl-no-stick-post target ()
  (let ((gp-0 (the int (-> *display* time-ratio))))
    (set-time-ratios *display* 1.0)
    (countdown (s5-0 gp-0)
      (set! (-> self control unknown-int40) s5-0)
      (flag-setup)
      (build-conversions (-> self control transv))
      (do-rotations1)
      (let ((s4-0 (new-stack-vector0))) (read-pad s4-0) (turn-to-vector s4-0 0.0))
      (add-thrust)
      (add-gravity)
      (do-rotations2-hl)
      (reverse-conversions (-> self control transv))
      (if *debug-segment*
        (add-frame (-> *display* frames (-> *display* on-screen) frame profile-bar 0)
                   'draw
                   (new 'static 'rgba :r #x40 :b #x40 :a #x80)))
      (fill-cache-integrate-and-collide! (-> self control) (-> self control transv) (-> self control root-prim collide-with))
      (if (logtest? (-> self control root-prim prim-core action) (collide-action edgegrab-possible))
        (find-edge-grabs! *target* *collide-cache*))
      (if *debug-segment*
        (add-frame (-> *display* frames (-> *display* on-screen) frame profile-bar 0)
                   'draw
                   (new 'static 'rgba :r #x80 :g #x60 :b #x40 :a #x80)))
      (bend-gravity)
      (hl-post-flag-setup))
    (set-time-ratios *display* (the float gp-0)))
  (if *debug-segment*
    (add-frame (-> *display* frames (-> *display* on-screen) frame profile-bar 0)
               'draw
               (new 'static 'rgba :r #x40 :b #x40 :a #x80)))
  ;;(ja-post)
  (if *debug-segment*
    (add-frame (-> *display* frames (-> *display* on-screen) frame profile-bar 0) 'draw (new 'static 'rgba :r #x80 :a #x80)))
  ;;(joint-points)
  (do-target-shadow)
  (target-powerup-process)
  (none))

(defbehavior target-hl-movement-post target ()
  (let* ((gp-0 (the int (-> *display* time-ratio))))
    (set-time-ratios *display* 1.0)
    (countdown (s5-0 gp-0)
    (set! (-> self control unknown-int40) s5-0)
      (flag-setup)
      (if (< (-> self control force-push-speed-mod) 0.0)
        (set! (-> self control force-push-speed-mod) (- 1.0 (-> self control cpad stick0-speed))))
      (build-conversions (-> self control transv))
      (do-rotations1)
      #|
      (let ((s4-0 (new-stack-vector0)))
        (read-pad s4-0)
        (let ((f30-0 (-> self control pad-stick-speed)))
          (if (and (< 0.0 f30-0)
                   (< 0.3 (-> self control pad-stick-speed))
                   (< (vector-dot (-> self control stick-vec) (-> self control last-stick-vec)) 0.2)
                   (< f30-0 0.7))
            (set! f30-0 0.0))
          (when (!= (-> self control force-push-speed-mod) 0.0)
            (let ((f0-12 (fmin 1.0 (-> self control force-push-speed-mod))))
              (set! (-> self control force-push-speed-mod) f0-12)
              (let ((a1-2 (vector-float*! (new 'stack-no-clear 'vector) (if (= f30-0 0.0) *zero-vector* s4-0) f30-0))
                    (a2-1 (vector-float*! (new 'stack-no-clear 'vector) (-> self control force-push-transv) (-> self control tongue-pull-force))))
                (vector-lerp! s4-0 a1-2 a2-1 f0-12)))
            (set! f30-0 (vector-length s4-0))
            (vector-normalize! s4-0 1.0))
          (turn-to-vector s4-0 f30-0)))|#
      (when (on-ground?)
        (hl-update-step-sound))
      
      (let ((s4-0 (new-stack-vector0)))
        (read-input s4-0)
        (let ((f30-0 (-> self control pad-stick-speed)))
          (turn-to-vector s4-0 f30-0)))

      (if (on-ground?)
          (unless (should-jump?)
            (hl-add-thrust))
          (if (= (-> *target* state name) 'target-hl-duck-high-jump-jump) (hl-add-air-thrust-launcher) (hl-add-air-thrust)))

      (if (= (-> *target* state name) 'target-hl-duck-high-jump-jump) (add-gravity) (hl-add-gravity))
      ;;(hl-add-gravity)
      (do-rotations2-hl)
      (reverse-conversions (-> self control transv))

      (if *debug-segment*
        (add-frame (-> *display* frames (-> *display* on-screen) frame profile-bar 0)
                   'draw
                   (new 'static 'rgba :r #x40 :b #x40 :a #x80)))

      (set! (-> self control reaction) target-collision-reaction)

      (fill-cache-integrate-and-collide! (-> self control)
                                         (-> self control transv)
                                         (-> self control root-prim collide-with))
      #|(if (logtest? (-> self control root-prim prim-core action) (collide-action edgegrab-possible))
        (find-edge-grabs! *target* *collide-cache*))|#
      ;; debug
      (if *debug-segment*
        (add-frame (-> *display* frames (-> *display* on-screen) frame profile-bar 0)
                   'draw
                   (new 'static 'rgba :r #x80 :g #x60 :b #x40 :a #x80)))
      ;;(bend-gravity)
      (hl-post-flag-setup))
    (set-time-ratios *display* (the float gp-0)))

  (if *debug-segment*
    (add-frame (-> *display* frames (-> *display* on-screen) frame profile-bar 0)
               'draw
               (new 'static 'rgba :r #x40 :b #x40 :a #x80)))

  (ja-post)
  (if *debug-segment*
    (add-frame (-> *display* frames (-> *display* on-screen) frame profile-bar 0)
               'draw
               (new 'static 'rgba :r #x80 :a #x80)))

  (joint-points)
  (do-target-shadow)
  (target-calc-camera-pos-hl)
  (target-powerup-process)
  (none))

(defbehavior target-hl-apply-jump target ()
  (set! (-> (-> self control transv) y) jump-speed)
)

(defbehavior target-hl-apply-longjump target ()
  (let* ((curvel   (-> self control transv))
         (cam-fwd  (-> *math-camera* inv-camera-rot vector 2))
         (speed    99000.0)
         (jump-up  90070.0))  ;; upward boost for long jump

    ;; horizontal look direction
    (set! (-> cam-fwd y) 0.0)
    (vector-normalize! cam-fwd 1.0)
    (when (time-elapsed? *last-step-time* (fsec 0.5))
      (hl-play-step-sound))
    ;; apply horizontal speed along look
    (vector-float*! cam-fwd cam-fwd speed)
    (set! (-> curvel x) (-> cam-fwd x))
    (set! (-> curvel z) (-> cam-fwd z))
    ;; add upward velocity
    (set! (-> curvel y) jump-up)))

(defbehavior target-should-use-launcher? target ()
  (when (= (-> self control unknown-symbol40) 'launch)
    (level-hint-spawn (text-id sidekick-launcher1) "sksp009d" (the-as entity #f) *entity-pool* (game-task none))
    (level-hint-spawn (text-id sidekick-launcher2) "sksp009e" (the-as entity #f) *entity-pool* (game-task none))
    (case (-> (level-get-target-inside *level*) name)
      (('citadel)
        (level-hint-spawn (text-id citadel-launcher2) "sksp0393" (the-as entity #f) *entity-pool* (game-task none))
        (level-hint-spawn (text-id citadel-launcher) "sksp0388" (the-as entity #f) *entity-pool* (game-task none))))
    enter-state
    (let ((a0-9 (-> self control unknown-dword60))
          (a1-5 (-> self control unknown-dword61))
          (a2-5 (-> self control last-transv2)))
      (set! (-> a2-5 quad) (-> (the-as vector (-> self control unknown-dword62)) quad))
      (go target-hl-launch (the-as float a0-9) (the-as symbol a1-5) a2-5 (-> self control unknown-dword63)))#t) #f)

(defbehavior target-hl-collide-set! target ((arg0 symbol) (arg1 float))
  (let ((gp-0 (-> self control)))
    (set! (-> self control unknown-symbol00) arg0)
    (set! (-> self control unknown-float90) arg1)
    (dotimes (v1-2 6)
      (set! (-> gp-0 body-spheres v1-2 prim-core offense) (collide-offense touch))
      (set! (-> gp-0 body-spheres v1-2 transform-index) -2))
    (case arg0
      (('duck-ground)
       (set! *target-current-collide-set* (collide-set duck-ground))
       (set! (-> self control unknown-float91) arg1)
       (let ((f30-0 (- 1.0 arg1)))
         (set! (-> gp-0 racer-cushion-targ y) 0.0)
         (sphere<-vector+r! (the-as sphere (-> gp-0 root-prim local-sphere))
                            (-> *TARGET-bank* root-offset)
                            (-> *TARGET-bank* root-radius))
         (set-vector! (-> gp-0 body-spheres 0 local-sphere)
                      0.0
                      (-> *TARGET-bank* body-radius)
                      (* 0.0 f30-0)
                      (-> *TARGET-bank* body-radius))
          #|
         (set-vector! (-> gp-0 body-spheres 1 local-sphere)
                      0.0
                      (+ (-> *TARGET-bank* body-radius) (* 2867.2 f30-0))
                      0.0
                      (-> *TARGET-bank* body-radius))|#
         (set-vector! (-> gp-0 body-spheres 2 local-sphere)
                      0.0
                      (+ (-> *TARGET-bank* body-radius) (* 5734.4 f30-0))
                      0.0
                      (-> *TARGET-bank* body-radius))))
      ;; not used, just and experiment
      (('duck-air)
       (set! *target-current-collide-set* (collide-set duck-air))
       (set! (-> self control unknown-float91) arg1)
       (let ((f30-0 (- 1.0 arg1)))
         (sphere<-vector+r! (the-as sphere (-> gp-0 root-prim local-sphere))
                            (-> *TARGET-bank* root-offset)
                            (-> *TARGET-bank* root-radius))
         (set-vector! (-> gp-0 body-spheres 0 local-sphere)
                      0.0
                      (+ 2867.2 (-> *TARGET-bank* body-radius))
                      (* 0.0 f30-0)
                      (-> *TARGET-bank* body-radius))
         (set-vector! (-> gp-0 body-spheres 1 local-sphere)
                      0.0
                      (+ 2867.2 (-> *TARGET-bank* body-radius))
                      0.0
                      (-> *TARGET-bank* body-radius))
         (set-vector! (-> gp-0 body-spheres 2 local-sphere)
                      0.0
                      (+ 2867.2 (-> *TARGET-bank* body-radius))
                      0.0
                      (-> *TARGET-bank* body-radius))))
      (else
       (set! *target-current-collide-set* (collide-set normal))
       (set! (-> self control unknown-float91) 0.0)
       (set! (-> gp-0 racer-cushion-targ y) 0.0)
       (sphere<-vector+r! (the-as sphere (-> gp-0 root-prim local-sphere))
                          (-> *TARGET-bank* root-offset)
                          (-> *TARGET-bank* root-radius))
        (let ((body-r (-> *TARGET-bank* body-radius))
              (foot-y (- (-> *TARGET-bank* body-radius) (* (-> *TARGET-bank* body-radius) 0.3)))
              (foot-r (* (-> *TARGET-bank* body-radius) 0.55))
              (foot-off (* (-> *TARGET-bank* body-radius) 0.55)))

          ;; root bottom
          (set-vector! (-> gp-0 body-spheres 0 local-sphere)
                      0.0
                      body-r
                      0.0
                      body-r)

          ;; head section
          (set-vector! (-> gp-0 body-spheres 2 local-sphere)
                      0.0
                      (+ 5734.4 body-r)
                      0.0
                      body-r)

          ;; bottom square – 4 spheres

          (set-vector! (-> gp-0 body-spheres 1 local-sphere)
                      (- foot-off)   ; X
                      foot-y         ; Y
                      (- foot-off)   ; Z
                      foot-r)

          (set-vector! (-> gp-0 body-spheres 3 local-sphere)
                      foot-off
                      foot-y
                      (- foot-off)
                      foot-r)

          (set-vector! (-> gp-0 body-spheres 4 local-sphere)
                      (- foot-off)
                      foot-y
                      foot-off
                      foot-r)

          (set-vector! (-> gp-0 body-spheres 5 local-sphere)
                      foot-off
                      foot-y
                      foot-off
                      foot-r)
                      
                      ))
                    
                    ))
  0)

(defbehavior target-hl-exit target ()
  (set! (-> self control cur-surf) *walk-mods*)
  (set! (-> self control collide-offset quad) (the-as uint128 0))
  (set! (-> self control unknown-vector14 quad) (the-as uint128 0))
  (set! (-> self control unknown-vector15 quad) (the-as uint128 0))
  (set! (-> self control racer-cushion-targ quad) (the-as uint128 0))
  (set! (-> self control force-push-speed-mod) 0.0)
  (set! (-> self control bend-target) 0.0)
  (logclear! (-> self state-flags)
             (state-flags sf02
                          being-attacked
                          do-not-notice
                          grabbed
                          first-person-mode
                          looking-at-enemy
                          falling-into-pool-of-bad
                          flop-hit-ground))
  (target-danger-set! 'harmless #f)
  (logior! (-> self water flags) (water-flags wt04))
  (logclear! (-> self water flags) (water-flags wt16))
  (set! (-> self water drip-mult) 1.0)
  (set! (-> self neck flex-blend) 1.0)
  (set! (-> self control unknown-float91) 0.0)
  ;;(logclear! (-> self draw status) (draw-status hidden))
  (logclear! (-> self skel status) (janim-status spool))
  (logclear! (-> self control status) (cshape-moving-flags csmf14))
  0
  (none))


;; Ducking stuff

(defun start-ground-duck ()
  (unless *ground-duck-started*
    (set! *ground-duck-started* #t)
    (set! *ground-duck-accum* 0.0)))

(defun start-ground-unduck ()
  (unless *ground-unduck-started*
    (set! *ground-unduck-started* #t)
    (set! *ground-unduck-accum* 0.0)))

(defbehavior apply-ground-duck target ()
  (cond
    ;; Duck key still held
    ((should-duck?)
     (when *ground-duck-started*
       (set! *ground-duck-accum*
             (+ *ground-duck-accum* (seconds-per-frame)))

       (when (>= *ground-duck-accum* 0.2)
         ;; SUCCESS: enter ducked state
         (set! *ground-duck-started* #f)
         (set! *ducked?* #t)
         ;; Make target smaller
         (target-hl-collide-set! 'duck-ground (the-as float 1.0))
         (go target-hl-movement-ground-duck))))

    ;; If we entered ground and we are not ducking, we should start unducking the camera
    ((and *ducked?* (not (should-duck?)))
       (set! *ground-unduck-accum*
             (+ *ground-unduck-accum* (seconds-per-frame)))    
      (start-ground-unduck)
       (when (>= *ground-unduck-accum* 0.1)
       (set! *ground-unduck-started* #f)
         (set! *ducked?* #f))
    )
    ;; Duck key released early
    (*ground-duck-started*
     (set! *ground-duck-started* #f)
     (set! *ground-duck-accum* 0.0)
     ;; We apply a little height like in HL (in hl is 18 units)
     (when (on-ground?) (+! (-> self control trans y) duck-hop))))
  0)

(defbehavior apply-air-duck target ()
  (when (should-duck?)
    (+! (-> self control trans y) duck-hop)
    (target-hl-collide-set! 'duck-ground (the-as float 1.0))
    (go target-hl-movement-air-duck)))

;; Swim stuff

(defbehavior in-swim-limits? target ()
  (let ((water-proc (handle->process (-> self water volume)))
        (limit 0.0))
  (cond 
    ((string= (the-as string (-> water-proc name)) "cave-water-2") (set! limit 76300.0))
    ((string= (the-as string (-> water-proc name)) "cave-water-3") (set! limit 99000.0))
    ((string= (the-as string (-> water-proc name)) "sunken-water-5") (set! limit -620004.9375))
    ((string= (the-as string (-> water-proc name)) "sunken-water-4") (set! limit -690004.9375))
    ((string= (the-as string (-> water-proc name)) "sunken-water-6") (set! limit -553004.9375))
    ((string= (the-as string (-> water-proc name)) "sunken-water-7") (set! limit -553004.9375))
    ((string= (the-as string (-> water-proc name)) "sunken-water-3") (set! limit -599760.0625))
    ((string= (the-as string (-> water-proc name)) "sunken-water-13") (set! limit -567982.2500))
    ((string= (the-as string (-> water-proc name)) "sunken-water-11") (set! limit -602582.2500))
    ((string= (the-as string (-> water-proc name)) "sunken-water-9") (set! limit -602582.2500))
    ((string= (the-as string (-> water-proc name)) "sunken-water-8") (set! limit -652582.2500))
    ((string= (the-as string (-> water-proc name)) "sunken-water-10") (set! limit -602582.2500))
    ((string= (the-as string (-> water-proc name)) "sunken-water-12") (set! limit -612582.2500))
    ((string= (the-as string (-> water-proc name)) "sunken-water-15") (set! limit -1036808.8125))
    ((string= (the-as string (-> water-proc name)) "sunken-water-16") (set! limit -1036808.8125))
    (else (set! limit -20348.3759)))


    (if (<= (-> self control trans y) limit)
      #t
      #f)))

(defbehavior should-add-swim-effects? target ()
  (let ((water-proc (handle->process (-> self water volume)))
        (limit 0.0))

  (cond 
    ((string= (the-as string (-> water-proc name)) "cave-water-2") (set! limit 137000.0))
    ((string= (the-as string (-> water-proc name)) "cave-water-3") (set! limit 172300.0))
    ((string= (the-as string (-> water-proc name)) "sunken-water-5") (set! limit -610004.9375))
    ((string= (the-as string (-> water-proc name)) "sunken-water-4") (set! limit -675004.9375))
    ((string= (the-as string (-> water-proc name)) "sunken-water-6") (set! limit -552004.9375))
    ((string= (the-as string (-> water-proc name)) "sunken-water-7") (set! limit -552004.9375))
    ((string= (the-as string (-> water-proc name)) "sunken-water-3") (set! limit -590582.2500))
    ((string= (the-as string (-> water-proc name)) "sunken-water-13") (set! limit -547982.2500))
    ((string= (the-as string (-> water-proc name)) "sunken-water-11") (set! limit -582582.2500))
    ((string= (the-as string (-> water-proc name)) "sunken-water-9") (set! limit -582682.2500))
    ((string= (the-as string (-> water-proc name)) "sunken-water-8") (set! limit -612582.2500))
    ((string= (the-as string (-> water-proc name)) "sunken-water-10") (set! limit -582682.2500))
    ((string= (the-as string (-> water-proc name)) "sunken-water-12") (set! limit -592582.2500))
    ((string= (the-as string (-> water-proc name)) "sunken-water-15") (set! limit -1034808.8125))
    ((string= (the-as string (-> water-proc name)) "sunken-water-16") (set! limit -1034808.8125))
    (else (set! limit -9348.3759)))


    (if (< (-> self control trans y) limit)
      (begin
        (pc-set-fog-intensity 10.0)
        (set! *should-show-swim-screen?* #t)
      )
      (begin
        (pc-set-fog-intensity 1.0)
        (set! *should-show-swim-screen?* #f)
      )
    )
  )
)

(defbehavior swim-exit-help-speed target ()
  (let ((water-proc (handle->process (-> self water volume)))
        (limit 0.0)
        (speed 50000.0))

  (cond 
    ((string= (the-as string (-> water-proc name)) "cave-water-2") (set! limit 137000.0) (set! speed 70000.0))
    ((string= (the-as string (-> water-proc name)) "cave-water-3") (set! limit 172300.0) (set! speed 30000.0))
    ((string= (the-as string (-> water-proc name)) "sunken-water-5") (set! limit -610004.9375) (set! speed 40000.0))
    ((string= (the-as string (-> water-proc name)) "sunken-water-4") (set! limit -675004.9375))
    ((string= (the-as string (-> water-proc name)) "sunken-water-6") (set! limit -552004.9375))
    ((string= (the-as string (-> water-proc name)) "sunken-water-7") (set! limit -552004.9375))
    ((string= (the-as string (-> water-proc name)) "sunken-water-3") (set! limit -590582.2500))
    ((string= (the-as string (-> water-proc name)) "sunken-water-13") (set! limit -547982.2500) (set! speed 40000.0))
    ((string= (the-as string (-> water-proc name)) "sunken-water-11") (set! limit -582582.2500))
    ((string= (the-as string (-> water-proc name)) "sunken-water-9") (set! limit -582682.2500) (set! speed 70000.0))
    ((string= (the-as string (-> water-proc name)) "sunken-water-8") (set! limit -612582.2500))
    ((string= (the-as string (-> water-proc name)) "sunken-water-10") (set! limit -582682.2500))
    ((string= (the-as string (-> water-proc name)) "sunken-water-12") (set! limit -592582.2500))
    ((string= (the-as string (-> water-proc name)) "sunken-water-15") (set! limit -1034808.8125))
    ((string= (the-as string (-> water-proc name)) "sunken-water-16") (set! limit -1034808.8125))
    (else (set! limit -9348.3759)))


    (if (> (-> self control trans y) limit)
      speed
      50000.0
    )
  )
)

(defbehavior hl-add-thrust-swim target ()
  (let* ((wishvel (-> self control trans-targ))
         (curvel  (-> self control ltransv))
         (frametime (seconds-per-frame))
         (maxspeed (if (target-has-eco-type? (pickup-type eco-blue))
                       hl-max-speed-swim-blue-eco
                       hl-max-speed-swim))
         (accel 200.0)
         (friction 6.0)
         (vert-damp 0.5)
         (sink-speed -8000.0)
         (wish-horz (new-stack-vector0))
         (wish-vert (new-stack-vector0))
         (pitch (-> (the-as camera-slave (-> *camera* slave 0)) tracking inv-mat vector 0 w)))

    (when *entered-swim?*
      (vector-xz-normalize! curvel (* (vector-xz-length curvel) 0.6))
      (set! (-> curvel y) (* (-> curvel y) vert-damp))
      ;; clear the flag so it runs only once
      *entered-swim?* #f)


    (let ((speed (vector-xz-length curvel)))
      (when (> speed 0.0)
        (let ((drop (* speed friction frametime))
              (new-speed (max 0.0 (- speed (* speed friction frametime)))))
          (vector-xz-normalize! curvel new-speed))))

      (let* ((using-forward?
              (or (should-move-forward?) (should-move-back?)))

            (h-scale (if using-forward?
                          (- 1.0 (abs pitch))
                          1.0))

            (wishspeed (vector-xz-length wishvel)))

        (when (> wishspeed 0.0)
          (vector-zero! wish-horz)
          (set! (-> wish-horz x) (-> wishvel x))
          (set! (-> wish-horz z) (-> wishvel z))

          (vector-normalize! wish-horz 1.0)
          (set! wishspeed (* wishspeed h-scale))

          (when (> wishspeed maxspeed)
            (set! wishspeed maxspeed))

          (let* ((curr-speed (vector-dot curvel wish-horz))
                (addspeed (- wishspeed curr-speed)))
            (when (> addspeed 0.0)
              (let ((accelspeed (* accel frametime wishspeed)))
                (when (> accelspeed addspeed)
                  (set! accelspeed addspeed))
                (vector+! curvel curvel
                          (vector-float*! (new-stack-vector0)
                                          wish-horz accelspeed)))))))

      (when (or (should-move-forward?) (should-move-back?))
        (let* ((dir (if (should-move-forward?) 1.0 -1.0))
              (vert-speed (* dir pitch (* 20000 accel) frametime)))
          (+! (-> curvel y) vert-speed)))
    
    (when (> (-> curvel y) hl-max-speed-swim) 
      (set! (-> curvel y) hl-max-speed-swim)
    )

    (when (< (-> curvel y) (- hl-max-speed-swim)) 
      (set! (-> curvel y) (- hl-max-speed-swim)))

    (let ((vert-input (-> wishvel y)))
      (cond
        ((should-jump?)
          (+! (-> curvel y) (if (near-wall? 500.0) (swim-exit-help-speed) jump-speed)))  

        ((not (= vert-input 0.0))
        (+! (-> curvel y) (* vert-input accel frametime)))
        ((if (fully-grounded? 2004.0)
            (set! (-> curvel y) 0.0)
            (if (not (or (should-move-left?) (should-move-right?))) 
              (+! (-> curvel y) sink-speed)
              (set! (-> curvel y) 0.0))))))

    (when (in-swim-limits?)
      (when (< (-> curvel y) 0.0)
        (set! (-> curvel y) 0.0)))

    (let ((speed (vector-xz-length curvel)))
      (when (> speed maxspeed)
        (vector-xz-normalize! curvel maxspeed)))))

(defbehavior hl-update-swim-sound target ()
  (when (time-elapsed? *last-step-time* (if (target-has-eco-type? (pickup-type eco-blue)) (fsec 0.8) (fsec 1.5)))
    (hl-play-step-sound)
    (set-time! *last-step-time*))
  (none))

(defbehavior target-hl-movement-swim-post target ()
  (let* ((gp-0 (the int (-> *display* time-ratio))))
    (set-time-ratios *display* 1.0)
    (countdown (s5-0 gp-0)
    (set! (-> self control unknown-int40) s5-0)
      (flag-setup)
      (if (< (-> self control force-push-speed-mod) 0.0)
        (set! (-> self control force-push-speed-mod) (- 1.0 (-> self control cpad stick0-speed))))
      (build-conversions (-> self control transv))
      (do-rotations1)

      (hl-update-swim-sound)
      (should-add-swim-effects?)
      (let ((s4-0 (new-stack-vector0)))
        (read-input s4-0)
        (let ((f30-0 (-> self control pad-stick-speed)))
          (turn-to-vector s4-0 f30-0)))

      (hl-add-thrust-swim)
      (do-rotations2-hl)
      (reverse-conversions (-> self control transv))

      (if *debug-segment*
        (add-frame (-> *display* frames (-> *display* on-screen) frame profile-bar 0)
                   'draw
                   (new 'static 'rgba :r #x40 :b #x40 :a #x80)))

      (set! (-> self control reaction) target-collision-reaction)

      (fill-cache-integrate-and-collide! (-> self control)
                                         (-> self control transv)
                                         (-> self control root-prim collide-with))

      ;; debug
      (if *debug-segment*
        (add-frame (-> *display* frames (-> *display* on-screen) frame profile-bar 0)
                   'draw
                   (new 'static 'rgba :r #x80 :g #x60 :b #x40 :a #x80)))
      (hl-post-flag-setup))
    (set-time-ratios *display* (the float gp-0)))

  (if *debug-segment*
    (add-frame (-> *display* frames (-> *display* on-screen) frame profile-bar 0)
               'draw
               (new 'static 'rgba :r #x40 :b #x40 :a #x80)))

  (ja-post)
  (if *debug-segment*
    (add-frame (-> *display* frames (-> *display* on-screen) frame profile-bar 0)
               'draw
               (new 'static 'rgba :r #x80 :a #x80)))

  (joint-points)
  (do-target-shadow)
  (target-calc-camera-pos-hl)
  (target-powerup-process)
  (none))