;;-*-Lisp-*-
(in-package goal)
(bundles "ENGINE.CGO" "GAME.CGO")
(require "engine/game/projectile-hls-h.gc")
(require "engine/common-obs/water-h.gc")
(require "engine/target/target-util.gc")
(require "engine/common-obs/process-drawable.gc")
(require "engine/mods/hl-weapons/hl-weapons.gc")

(defconstant crowbar-damage 60)
(defconstant shot-damage 20)
;; note: changed for high fps

;; DECOMP BEGINS

(deftype search-info-hl (structure)
  ((point        vector :inline)
   (best-point   vector :inline)
   (match-handle handle)
   (match        projectile-hl)
   (best         float)
   (radius       float)
   (rating       uint32)
   (require      uint32)
   (mask         uint32)
   (rot-base     vector :inline)
   (rot-range    float)))


(define *search-info-hl* (new 'global 'search-info-hl))

(defun projectile-hl-collision-reaction ((arg0 collide-shape-moving) (arg1 collide-shape-intersect) (arg2 vector) (arg3 vector))
  (local-vars (sv-64 vector) (sv-68 vector) (sv-72 matrix) (sv-80 int) (sv-224 symbol))
  (set! sv-64 (new-stack-vector0))
  (set! sv-68 (new-stack-vector0))
  (set! sv-72 (new 'stack-no-clear 'matrix))
  (set! sv-80 0)
  (set! (-> sv-72 vector 0 quad) (-> arg3 quad))
  (let ((a1-1 (new 'stack-no-clear 'vector)))
    (vector-float*! a1-1 (-> arg1 move-vec) (-> arg1 best-u))
    (move-by-vector! arg0 a1-1))
  (set-and-handle-pat! arg0 (-> arg1 best-tri pat))
  (case (-> arg1 best-tri pat material)
    (((pat-material stopproj)) (send-event (-> arg0 process) 'die)))
  (vector-! sv-64 (the-as vector (-> arg1 best-from-prim prim-core)) (-> arg1 best-tri intersect))
  (set! (-> sv-64 w) 1.0)
  (vector-normalize! sv-64 1.0)
  (set! (-> arg0 coverage) (vector-dot sv-64 (-> arg1 best-tri normal)))
  (let ((v1-22 (-> sv-64 quad))) (set! (-> sv-68 quad) v1-22))
  (when (= (-> arg1 best-u) 0.0)
    (let ((a1-7 (vector-float*! (new 'stack-no-clear 'vector) sv-68 32.0))) (move-by-vector! arg0 a1-7)))
  (set! (-> arg0 surface-normal quad) (-> sv-68 quad))
  (set! (-> arg0 poly-normal quad) (-> arg1 best-tri normal quad))
  (set! (-> arg0 surface-angle) (vector-dot sv-68 (-> arg0 dynam gravity-normal)))
  (set! (-> arg0 poly-angle) (vector-dot (-> arg0 poly-normal) (-> arg0 dynam gravity-normal)))
  (set! (-> arg0 touch-angle)
        (vector-dot sv-68 (vector-normalize! (vector-negate! (new-stack-vector0) (the-as vector sv-72)) 1.0)))
  (if (< (-> arg0 poly-angle) -0.2) (set! sv-80 (logior sv-80 16)))
  (set! sv-224 (< (fabs (-> arg0 surface-angle)) (-> *pat-mode-info* (-> arg0 cur-pat mode) wall-angle)))
  (if (not (logtest? (-> arg0 prev-status) (cshape-moving-flags onsurf)))
    (set! (-> arg0 ground-impact-vel) (- (vector-dot (-> arg0 transv) (-> arg0 dynam gravity-normal)))))
  (set! sv-80 (logior sv-80 4))
  (if (-> arg1 best-to-prim) (set! sv-80 (logior sv-80 32)))
  (cond
    (sv-224
     (set! sv-80 (logior sv-80 8))
     (set! (-> arg0 cur-pat mode) 1)
     (set! (-> arg0 local-normal quad) (-> sv-68 quad)))
    (else (set! sv-80 (logior sv-80 1)) (set! (-> arg0 local-normal quad) (-> sv-68 quad))))
  (vector-reflect-flat-above! arg2 (the-as vector sv-72) sv-68)
  (when (and (not sv-224) (>= (-> arg0 coverage) 0.9))
    (set! sv-80 (logior sv-80 2))
    (set! (-> arg0 ground-poly-normal quad) (-> arg0 poly-normal quad))
    (when (!= (-> arg0 poly-pat mode) (pat-mode wall))
      (set! (-> arg0 ground-pat) (-> arg0 poly-pat))
      (set! (-> arg0 ground-touch-point quad) (-> arg1 best-tri intersect quad))))
  (logior! (-> arg0 status) sv-80)
  (the-as cshape-moving-flags sv-80))

(defpartgroup group-yellow-eco-fireball
  :id 102
  :duration (seconds 1)
  :bounds (static-bspherem 0 0 0 3)
  :parts
  ((sp-item 349 :flags (launch-asap) :binding 350)
   (sp-item 350 :flags (start-dead launch-asap) :binding 351)
   (sp-item 351 :flags (start-dead launch-asap) :binding 352)
   (sp-item 352 :flags (start-dead) :binding 353)
   (sp-item 352 :flags (start-dead) :binding 353)
   (sp-item 352 :flags (start-dead) :binding 353)
   (sp-item 352 :flags (start-dead) :binding 353)
   (sp-item 352 :flags (start-dead) :binding 353)
   (sp-item 352 :flags (start-dead) :binding 353)
   (sp-item 352 :flags (start-dead) :binding 353)
   (sp-item 352 :flags (start-dead) :binding 353)
   (sp-item 352 :flags (start-dead) :binding 353)
   (sp-item 352 :flags (start-dead) :binding 353)
   (sp-item 352 :flags (start-dead) :binding 353)
   (sp-item 353 :fade-after (meters 100) :falloff-to (meters 100) :flags (start-dead))
   (sp-item 353 :fade-after (meters 100) :falloff-to (meters 100) :flags (start-dead))
   (sp-item 353 :fade-after (meters 100) :falloff-to (meters 100) :flags (start-dead))
   (sp-item 353 :fade-after (meters 100) :falloff-to (meters 100) :flags (start-dead))
   (sp-item 353 :fade-after (meters 100) :falloff-to (meters 100) :flags (start-dead))
   (sp-item 353 :fade-after (meters 100) :falloff-to (meters 100) :flags (start-dead))
   (sp-item 353 :fade-after (meters 100) :falloff-to (meters 100) :flags (start-dead))
   (sp-item 353 :fade-after (meters 100) :falloff-to (meters 100) :flags (start-dead))
   (sp-item 353 :fade-after (meters 100) :falloff-to (meters 100) :flags (start-dead))
   (sp-item 353 :fade-after (meters 100) :falloff-to (meters 100) :flags (start-dead))
   (sp-item 353 :fade-after (meters 100) :falloff-to (meters 100) :flags (start-dead))
   (sp-item 353 :fade-after (meters 100) :falloff-to (meters 100) :flags (start-dead))
   (sp-item 353 :fade-after (meters 100) :falloff-to (meters 100) :flags (start-dead))
   (sp-item 353 :fade-after (meters 100) :falloff-to (meters 100) :flags (start-dead))
   (sp-item 353 :fade-after (meters 100) :falloff-to (meters 100) :flags (start-dead))
   (sp-item 353 :fade-after (meters 100) :falloff-to (meters 100) :flags (start-dead))
   (sp-item 353 :fade-after (meters 100) :falloff-to (meters 100) :flags (start-dead))
   (sp-item 353 :fade-after (meters 100) :falloff-to (meters 100) :flags (start-dead))
   (sp-item 353 :fade-after (meters 100) :falloff-to (meters 100) :flags (start-dead))
   (sp-item 353 :fade-after (meters 100) :falloff-to (meters 100) :flags (start-dead))))

(defpart 349
  :init-specs
  ((:texture (starflash effects))
   (:num 1.0)
   (:scale-x (meters 0.01))
   (:scale-y :copy scale-x)
   (:a 0.0)
   (:timer (seconds 4))
   (:flags (bit3))
   (:func 'sparticle-track-root-prim)))

(defpart 350
  :init-specs
  ((:texture (starflash effects))
   (:num 1.0)
   (:x (meters 0) (meters 16))
   (:y (meters 4) (meters 16))
   (:z (meters 0))
   (:scale-x (meters 5))
   (:rot-z (degrees 0) (degrees 360))
   (:scale-y :copy scale-x)
   (:r 128.0 128.0)
   (:g 64.0 64.0)
   (:a 32.0)
   (:vel-x (meters -0.10666667) 1 (meters 0.21333334))
   (:rotvel-z (degrees -0.4) 1 (degrees 0.8))
   (:timer (seconds 4))
   (:flags (bit2 bit3 bit7))))

(defpart 351
  :init-specs
  ((:texture (bigpuff effects))
   (:num 2.0)
   (:y (meters 0) (meters 16))
   (:z (meters 0))
   (:scale-x (meters 1.5) (meters 0.5))
   (:rot-z (degrees 0) (degrees 360))
   (:scale-y :copy scale-x)
   (:r 128.0 128.0)
   (:g 64.0 64.0)
   (:a 64.0)
   (:omega 0.0 65536.0)
   (:vel-x (meters 0.11259259))
   (:rotvel-z (degrees -0.3) 1 (degrees 0.6))
   (:timer (seconds 4))
   (:flags (bit2 bit3 bit7))))

(defpart 352
  :init-specs
  ((:texture (bigpuff effects))
   (:num 1.0)
   (:scale-x (meters 1.5) (meters 0.5))
   (:rot-z (degrees 0) (degrees 360))
   (:scale-y :copy scale-x)
   (:r 128.0 128.0)
   (:g 64.0 64.0)
   (:a 64.0)
   (:scalevel-x (meters -0.02))
   (:rotvel-z (degrees -0.3) 1 (degrees 0.6))
   (:scalevel-y :copy scalevel-x)
   (:fade-a -1.0)
   (:timer (seconds 0.18))
   (:flags (bit2 bit3))))

(defpart 353
  :init-specs
  ((:texture (hotdot effects))
   (:num 0.5 0.5)
   (:y (meters -0.05))
   (:scale-x (meters 0.3) (meters 0.1))
   (:scale-y :copy scale-x)
   (:r 100.0 28.0)
   (:g 64.0 64.0)
   (:b 0.0)
   (:a 96.0)
   (:vel-y (meters 0.005) (meters 0.011666667))
   (:scalevel-x (meters -0.000909091))
   (:scalevel-y :copy scalevel-x)
   (:fade-g -0.4)
   (:fade-a -0.024242423)
   (:accel-y (meters -0.000100000005) (meters -0.0003))
   (:friction 0.93)
   (:timer (seconds 0.1) (seconds 0.997))
   (:flags (bit2 bit3))
   (:next-time (seconds 0.3))
   (:next-launcher 354)
   (:conerot-x (degrees 0) (degrees 180))
   (:conerot-y (degrees 0) (degrees 360))
   (:conerot-radius (meters 0.3))))

(defpart 354
  :init-specs ((:fade-r 0.0)))

(defpartgroup group-part-yellow-eco-fireball-launcher
  :id 103
  :duration (seconds 2)
  :bounds (static-bspherem 0 0 0 6)
  :parts
  ((sp-item 355 :flags (launch-asap))
   (sp-item 356 :flags (bit1) :period (seconds 2.1) :length (seconds 0.05))
   (sp-item 357 :flags (launch-asap))
   (sp-item 358 :flags (launch-asap) :binding 359)
   (sp-item 359 :flags (start-dead launch-asap))
   (sp-item 359 :flags (start-dead launch-asap))
   (sp-item 359 :flags (start-dead launch-asap))
   (sp-item 359 :flags (start-dead launch-asap))
   (sp-item 359 :flags (start-dead launch-asap))
   (sp-item 359 :flags (start-dead launch-asap))
   (sp-item 359 :flags (start-dead launch-asap))
   (sp-item 359 :flags (start-dead launch-asap))
   (sp-item 359 :flags (start-dead launch-asap))
   (sp-item 359 :flags (start-dead launch-asap))
   (sp-item 359 :flags (start-dead launch-asap))
   (sp-item 359 :flags (start-dead launch-asap))
   (sp-item 359 :flags (start-dead launch-asap))
   (sp-item 359 :flags (start-dead launch-asap))
   (sp-item 359 :flags (start-dead launch-asap))
   (sp-item 359 :flags (start-dead launch-asap))))

(defpart 355
  :init-specs
  ((:texture (starflash effects))
   (:num 1.0)
   (:scale-x (meters 8))
   (:rot-z (degrees 0) (degrees 360))
   (:scale-y :copy scale-x)
   (:r 255.0)
   (:g 128.0)
   (:a 64.0)
   (:scalevel-x (meters -0.06666667))
   (:rotvel-z (degrees -204.8) 1 (degrees 409.6))
   (:scalevel-y :copy scalevel-x)
   (:fade-a 0.0)
   (:timer (seconds 0.2))
   (:flags (bit2 bit3))))

(defpart 357
  :init-specs
  ((:texture (bigpuff effects))
   (:num 5.0)
   (:x (meters -0.6) (meters 1.2))
   (:y (meters -0.6) (meters 1.2))
   (:z (meters -0.6) (meters 1.2))
   (:scale-x (meters 1.5) (meters 0.75))
   (:rot-z (degrees 0) (degrees 360))
   (:scale-y :copy scale-x)
   (:r 100.0 28.0)
   (:g 64.0 64.0)
   (:b 32.0)
   (:a 32.0 32.0)
   (:scalevel-x (meters 0.0044444446))
   (:rotvel-z (degrees -0.3) (degrees 0.6))
   (:scalevel-y :copy scalevel-x)
   (:fade-g -0.14222223)
   (:fade-a -0.14222223)
   (:accel-y (meters -0.000016666667))
   (:timer (seconds 1.5))
   (:flags (bit2 bit3))))

(defpart 356
  :init-specs
  ((:texture (starflash effects))
   (:num 12.0)
   (:scale-x (meters 0.3) (meters 0.1))
   (:scale-y :copy scale-x)
   (:r 100.0 28.0)
   (:g 64.0 64.0)
   (:b 0.0)
   (:a 128.0)
   (:vel-y (meters 0) (meters 0.053333335))
   (:scalevel-x (meters -0.0025000002))
   (:scalevel-y :copy scalevel-x)
   (:fade-g -1.0666667)
   (:fade-a -0.17777778)
   (:accel-y (meters -0.001))
   (:friction 0.99)
   (:timer (seconds 0.2) (seconds 0.197))
   (:flags (bit2 bit3))
   (:conerot-x (degrees 0) (degrees 120))
   (:conerot-y (degrees 90) (degrees 180))))

(defpart 360
  :init-specs
  ((:texture (starflash effects))
   (:num 24.0)
   (:scale-x (meters 0.3) (meters 0.1))
   (:scale-y :copy scale-x)
   (:r 100.0 28.0)
   (:g 64.0 64.0)
   (:b 0.0)
   (:a 128.0)
   (:vel-y (meters 0) (meters 0.053333335))
   (:scalevel-x (meters -0.0025000002))
   (:scalevel-y :copy scalevel-x)
   (:fade-g -1.0666667)
   (:fade-a -0.17777778)
   (:accel-y (meters -0.001))
   (:friction 0.99)
   (:timer (seconds 0.2) (seconds 0.197))
   (:flags (bit2 bit3))
   (:conerot-x (degrees 0) (degrees 180))
   (:conerot-y (degrees 0) (degrees 360))))

(defpart 358
  :init-specs
  ((:texture (starflash effects))
   (:num 16.0)
   (:scale-x (meters 0.1))
   (:scale-y :copy scale-x)
   (:a 1.0)
   (:vel-y (meters 0.02) (meters 0.013333334))
   (:accel-y (meters -0.0005))
   (:friction 0.99)
   (:timer (seconds 1.1))
   (:flags (bit2 bit3))
   (:conerot-x (degrees 0) (degrees 100.00001))
   (:conerot-y (degrees 90) (degrees 180))))

(defpart 361
  :init-specs
  ((:texture (starflash effects))
   (:num 32.0)
   (:scale-x (meters 0.1))
   (:scale-y :copy scale-x)
   (:a 1.0)
   (:vel-y (meters 0.02) (meters 0.013333334))
   (:accel-y (meters -0.0005))
   (:friction 0.99)
   (:timer (seconds 1.1))
   (:flags (bit2 bit3))
   (:conerot-x (degrees 0) (degrees 180))
   (:conerot-y (degrees 0) (degrees 360))))

(defpart 359
  :init-specs
  ((:texture (hotdot effects))
   (:num 1.0)
   (:y (meters 0) (meters 16))
   (:z (meters 0.1) (meters 0.2))
   (:scale-x (meters 0.3) (meters 0.1))
   (:rot-z (degrees 0) (degrees 360))
   (:scale-y :copy scale-x)
   (:r 100.0 28.0)
   (:g 64.0 64.0)
   (:b 0.0)
   (:a 64.0 64.0)
   (:omega 0.0 65536.0)
   (:vel-x (meters 0.10666667))
   (:scalevel-x (meters -0.000909091))
   (:rotvel-z (degrees -0.3) 1 (degrees 0.6))
   (:scalevel-y :copy scalevel-x)
   (:fade-g -0.26666668)
   (:fade-a -0.19393939)
   (:timer (seconds 0.3) (seconds 0.797))
   (:flags (bit2 bit3 bit7))))

(defpartgroup group-part-hl-weapon-fire-hit
  :id 104
  :duration (seconds 2)
  :flags (use-local-clock)
  :bounds (static-bspherem 0 0 0 6)
  :parts
  ((sp-item 2059 :fade-after (meters 80) :falloff-to (meters 80) :period (seconds 2) :length (seconds 0.135))
   (sp-item 2060 :fade-after (meters 80) :falloff-to (meters 80) :period (seconds 2) :length (seconds 0.135))
   (sp-item 2062 :fade-after (meters 120) :falloff-to (meters 120) :period (seconds 2) :length (seconds 0.067))
   ))

(defpartgroup group-part-hl-crowbar-hit
  :id 709
  :duration (seconds 2)
  :flags (use-local-clock)
  :bounds (static-bspherem 0 0 0 6)
  :parts
  ((sp-item 2059 :fade-after (meters 80) :falloff-to (meters 80) :period (seconds 2) :length (seconds 0.135))
   ))

;; small particles
(defpart 2060
  :init-specs
  ((:texture (hotdot effects))
   (:num 2.0)
   (:scale-x (meters 0.05) (meters 0.05))
   (:scale-y :copy scale-x)
   (:r 0.0)
   (:g 0.0)
   (:b 0.0)
   (:a 255.0 80.0)
   (:vel-y (meters -0.1) (meters -0.1))
   (:accel-y (meters -0.003) (meters -0.104))
   (:friction 0.1)
   (:timer (seconds 0.1) (seconds 0.2))
   (:flags (bit2 bit14))
   (:next-time (seconds 0.1) (seconds 0.1))
   (:next-launcher 2063)
   (:conerot-x (degrees 80) (degrees 100))
   (:conerot-y (degrees 120) (degrees 30))
   (:conerot-radius (meters 0.05) (meters 0.15))))

;; flash
(defpart 2062
  :init-specs
  ((:texture (hotdot effects))
   (:num 1.0)
   (:scale-x (meters 0.5))
   (:rot-z (degrees 0) (degrees 180))
   (:scale-y (meters 0.01))
   (:r 255.0)
   (:g 196.0)
   (:b 0.0)
   (:a 32.0 64.0)
   (:scalevel-y (meters 0.05))
   (:fade-a -1.6)
   (:timer (seconds 0.01))
   (:flags (bit2 bit3 bit14))))

;; wall hole
(defpart 2059
  :init-specs
  ((:texture (starflash effects))
   (:num 2.0)
   (:scale-x (meters 0.15))
   (:scale-y :copy scale-x)
   (:r 0.0)
   (:g 0.0)
   (:b 0.0)
   (:a 10.0)
   (:timer (seconds 0.1))
   (:flags (bit2 bit14))))

(defpart 2064
  :init-specs ((:fade-r -0.53333336) (:fade-g -0.53333336) (:fade-b -1.0666667) (:fade-a -0.53333336)))

(defmethod projectile-hl-method-24 ((this projectile-hl))
  (set! (-> this has-damaged?) #f)
  (spawn (-> this part) (the-as vector (-> this root root-prim prim-core)))
  0
  (none))

(defmethod projectile-hl-method-28 ((this projectile-hl))
  0
  (none))

(defstate projectile-hl-moving (projectile-hl)
  :virtual #t
  :event
    (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
      (case message
        (('touched)
          (when (and (-> self attack-mode)
                      (not (-> self has-damaged?)))
            (set! (-> self has-damaged?) #t)
           (when (cond
                   ((= (-> proc type) target)
                    (send-event proc 'attack-hl (-> block param 0) (static-attack-info ((mode (-> self attack-mode)))))
                    )
                   (else
                    (let ((a1-2 (new 'stack-no-clear 'event-message-block)))
                      (set! (-> a1-2 from) self)
                      (set! (-> a1-2 num-params) 4)
                      (set! (-> a1-2 message) 'attack-hl)
                      (set! (-> a1-2 param 0) (-> block param 0))
                      (set! (-> a1-2 param 1) (the-as uint (-> self attack-mode)))
                      (let ((v1-13 (+ *global-attack-id* 1))) (set! *global-attack-id* v1-13) (set! (-> a1-2 param 2) (the-as uint v1-13)))
                      (set! (-> a1-2 param 3) (the-as int8 0))
                      (set! (-> a1-2 param 4) (the-as int8 (if (target-has-eco-type? (pickup-type eco-red)) (* shot-damage 2) shot-damage))) ;; This will be the damage, red eco doubles the damage
                      (send-event-function proc a1-2))))
             (let ((v1-14 (-> self notify-handle)))
               (if (handle->process v1-14) (send-event (-> v1-14 process 0) 'notify 'attack-hl proc)))
             (+! (-> self hits) 1)
             (if (>= (-> self hits) (-> self max-hits)) (go-virtual projectile-hl-impact)))))
        (('die) (go-virtual projectile-hl-impact))))
  :enter
    (behavior ()
      (set-time! (-> self state-time)))
  :code
    (behavior ()
      (let ((gp-0 #f))
        (while (not (time-elapsed? (-> self state-time) (-> self timeout)))
          (let ((s5-0 (the int (-> *display* time-ratio))))
            (set-time-ratios *display* 1.0)
            (countdown (s4-0 s5-0)
              (if gp-0 (go-virtual projectile-hl-impact))
              (projectile-hl-method-28 self)
              ((-> self update-velocity) self)
              (when (logtest? (-> self options) 2)
                (seek! (-> self tween) 1.0 (* 0.5 (seconds-per-frame)))
                (let ((f0-6 (vector-vector-distance (-> self root trans) (-> self target))))
                  (cond
                    ((< f0-6 20480.0) (seek! (-> self tween) 1.0 (* 3.0 (seconds-per-frame))))
                    ((< f0-6 40960.0) (seek! (-> self tween) 1.0 (seconds-per-frame))))))
              (let ((s3-0 (new 'stack-no-clear 'vector)))
                (set! (-> s3-0 quad) (-> self root trans quad))
                (fill-cache-integrate-and-collide! (-> self root) (-> self root transv) (-> self root root-prim collide-with))
                (set! (-> self old-dist (-> self old-dist-count)) (* 0.0625 (vector-vector-distance s3-0 (-> self root trans)))))
              (set! (-> self old-dist-count) (logand (+ (-> self old-dist-count) 1) 15))
              (let ((f0-16 0.0))
                (countdown (v1-35 16)
                  (+! f0-16 (-> self old-dist v1-35)))
                ;; og:preserve-this changed for high fps. This fixes projectile-hl collision issues
                (if (or (and (logtest? (-> self root status) (cshape-moving-flags twall))
                             (< f0-16 (* (-> *display* time-adjust-ratio) (meters 0.5))))
                        (< f0-16 (* (-> *display* time-adjust-ratio) (meters 0.05))))
                  (set! gp-0 #t))
                  
                  ))
            (set-time-ratios *display* (the float s5-0)))
          (projectile-hl-method-24 self)
          (suspend)))
      (go-virtual projectile-hl-dissipate)))

(defstate projectile-hl-moving (hl-crowbar-hit)
  :virtual #t
  :event
    (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
      (case message
        (('touched)
          (when (and (-> self attack-mode)
                      (not (-> self has-damaged?)))
            (set! (-> self has-damaged?) #t)
           (when (cond
                   ((= (-> proc type) target)
                    (send-event proc 'attack-hl (-> block param 0) (static-attack-info ((mode (-> self attack-mode)))))
                    )
                   (else
                    (let ((a1-2 (new 'stack-no-clear 'event-message-block)))
                      (set! (-> a1-2 from) self)
                      (set! (-> a1-2 num-params) 4)
                      (set! (-> a1-2 message) 'attack-hl)
                      (set! (-> a1-2 param 0) (-> block param 0))
                      (set! (-> a1-2 param 1) (the-as uint (-> self attack-mode)))
                      (let ((v1-13 (+ *global-attack-id* 1))) (set! *global-attack-id* v1-13) (set! (-> a1-2 param 2) (the-as uint v1-13)))
                      (set! (-> a1-2 param 3) (the-as int8 0))
                      (set! (-> a1-2 param 4) (the-as int8 (if (target-has-eco-type? (pickup-type eco-red)) (* crowbar-damage 2) crowbar-damage))) ;; This will be the damage, red eco doubles the damage
                      (send-event-function proc a1-2))))
             (let ((v1-14 (-> self notify-handle)))
               (if (handle->process v1-14) (send-event (-> v1-14 process 0) 'notify 'attack-hl proc)))
             (+! (-> self hits) 1)
             (if (>= (-> self hits) (-> self max-hits)) (go-virtual projectile-hl-impact)))))
        (('die) (go-virtual projectile-hl-impact))))
  :enter
    (behavior ()
      (set-time! (-> self state-time)))
  :code
    (behavior ()
      (let ((gp-0 #f))
        (while (not (time-elapsed? (-> self state-time) (-> self timeout)))
          (let ((s5-0 (the int (-> *display* time-ratio))))
            (set-time-ratios *display* 1.0)
            (countdown (s4-0 s5-0)
              (if gp-0 (go-virtual projectile-hl-impact))
              (projectile-hl-method-28 self)
              ((-> self update-velocity) self)
              (when (logtest? (-> self options) 2)
                (seek! (-> self tween) 1.0 (* 0.5 (seconds-per-frame)))
                (let ((f0-6 (vector-vector-distance (-> self root trans) (-> self target))))
                  (cond
                    ((< f0-6 20480.0) (seek! (-> self tween) 1.0 (* 3.0 (seconds-per-frame))))
                    ((< f0-6 40960.0) (seek! (-> self tween) 1.0 (seconds-per-frame))))))
              (let ((s3-0 (new 'stack-no-clear 'vector)))
                (set! (-> s3-0 quad) (-> self root trans quad))
                (fill-cache-integrate-and-collide! (-> self root) (-> self root transv) (-> self root root-prim collide-with))
                (set! (-> self old-dist (-> self old-dist-count)) (* 0.0625 (vector-vector-distance s3-0 (-> self root trans)))))
              (set! (-> self old-dist-count) (logand (+ (-> self old-dist-count) 1) 15))
              (let ((f0-16 0.0))
                (countdown (v1-35 16)
                  (+! f0-16 (-> self old-dist v1-35)))
                ;; og:preserve-this changed for high fps. This fixes projectile-hl collision issues
                (if (or (and (logtest? (-> self root status) (cshape-moving-flags twall))
                             (< f0-16 (* (-> *display* time-adjust-ratio) (meters 0.5))))
                        (< f0-16 (* (-> *display* time-adjust-ratio) (meters 0.05))))
                  (set! gp-0 #t))
                  
                  ))
            (set-time-ratios *display* (the float s5-0)))
          (projectile-hl-method-24 self)
          (suspend)))
      (go-virtual projectile-hl-dissipate)))

(defun projectile-hl-update-velocity-space-wars ((arg0 projectile-hl))
  (let ((s5-1 (vector-! (new 'stack-no-clear 'vector) (-> arg0 target) (-> arg0 root trans))))
    (let ((s4-0 (new 'stack-no-clear 'vector))
          (s3-0 (vector-normalize-copy! (new 'stack-no-clear 'vector) (-> arg0 root transv) 1.0))
          (f30-0 (vector-length (-> arg0 root transv))))
      (if (logtest? (-> arg0 root status) (cshape-moving-flags tsurf)) (vector-flatten! s5-1 s5-1 (-> arg0 root local-normal)))
      (vector-normalize-copy! s4-0 s5-1 1.0)
      (if (and (or (not (handle->process (-> arg0 last-target)))
                   (zero? (-> (the-as target (handle->process (-> arg0 last-target))) control root-prim prim-core collide-as)))
               (< (vector-dot s4-0 s3-0) 0.0))
        (go (method-of-object arg0 projectile-hl-dissipate)))
      (vector-deg-slerp (-> arg0 root transv) s3-0 s4-0 (-> arg0 tween))
      (vector-normalize! (-> arg0 root transv) f30-0))
    (vector+! (-> arg0 root transv) (-> arg0 root transv) s5-1))
  (vector-v++! (-> arg0 root transv) (compute-acc-due-to-gravity (-> arg0 root) (new-stack-vector0) 0.0))
  (if (< (-> arg0 max-speed) (vector-length (-> arg0 root transv)))
    (vector-normalize! (-> arg0 root transv) (-> arg0 max-speed)))
  (if (logtest? (-> arg0 options) 1) (set! (-> arg0 root transv y) -0.0))
  0
  (none))

(defstate projectile-hl-impact (projectile-hl)
  :virtual #t
  :code
    (behavior ()
      (when (!= (-> *hl-weapons* last-hit-pat-mode) (pat-mode obstacle))
        (process-spawn part-tracker
                      :init
                      part-tracker-init
                      (-> *part-group-id-table* 104)
                      -1
                      #f
                      #f
                      #f
                      (-> self root root-prim prim-core)
                      :to
                      *entity-pool*)
                      
                      ))
      (if (nonzero? (-> self sound-id)) (sound-stop (-> self sound-id)))
      (suspend)
      (go-virtual projectile-hl-die))

(defstate projectile-hl-impact (hl-crowbar-hit)
  :virtual #t
  :code
    (behavior ()
      (when (!= (-> *hl-weapons* last-hit-pat-mode) (pat-mode obstacle))
        (process-spawn part-tracker
                      :init
                      part-tracker-init
                      (-> *part-group-id-table* 709)
                      -1
                      #f
                      #f
                      #f
                      (-> self root root-prim prim-core)
                      :to
                      *entity-pool*)
                      
                      )    
    
    ))

(defstate projectile-hl-dissipate (projectile-hl)
  :virtual #t
  :code
    (behavior ()
      (process-spawn part-tracker
                     :init
                     part-tracker-init
                     (-> *part-group-id-table* 104)
                     -1
                     #f
                     #f
                     #f
                     (-> self root root-prim prim-core)
                     :to
                     *entity-pool*)
      (suspend)
      (go-virtual projectile-hl-die)))

(defmethod projectile-hl-method-27 ((this projectile-hl))
  0
  (none))

(defmethod projectile-hl-method-25 ((this projectile-hl))
  (go (method-of-object this projectile-hl-moving))
  0
  (none))

(defstate projectile-hl-die (projectile-hl)
  :virtual #t
  :code
    (behavior ()
      (let ((v1-0 (-> self notify-handle))) (if (handle->process v1-0) (send-event (-> v1-0 process 0) 'notify 'die)))
      (cleanup-for-death self)))

(defmethod deactivate ((this projectile-hl))
  (if (nonzero? (-> this sound-id)) (sound-stop (-> this sound-id)))
  ((method-of-type process-drawable deactivate) this)
  (none))

(defbehavior projectile-hl-init-by-other projectile-hl ((arg0 entity-actor) (arg1 vector) (arg2 vector) (arg3 uint) (arg4 handle))
  (stack-size-set! (-> self main-thread) 512)
  (set! (-> self has-damaged?) #f)
  (set! (-> self entity) arg0)
  (set! (-> self attack-mode) #f)
  (set! (-> self update-velocity) projectile-hl-update-velocity-space-wars)
  (set! (-> self max-speed) 40960.0)
  (set! (-> self max-turn) 18204.445)
  (set! (-> self tween) 1.0)
  (set! (-> self last-target) arg4)
  (set! (-> self timeout) (seconds 1))
  (set! (-> self options) arg3)
  (set! (-> self notify-handle) (the-as handle #f))
  (countdown (v1-4 16)
    (set! (-> self old-dist v1-4) 4095996000.0))
  (projectile-hl-method-26 self)
  (set! (-> self root dynam gravity y) 0.0)
  (set! (-> self root dynam gravity-length) 0.0)
  (set! (-> self root dynam gravity-max) 0.0)
  (set! (-> self root trans quad) (-> arg1 quad))
  (set! (-> self base-trans quad) (-> arg1 quad))
  (set! (-> self parent-base quad) (-> arg1 quad))
  (quaternion-copy! (-> self root quat) (-> (the-as process-drawable (-> self parent 0)) root quat))
  (quaternion-copy! (the-as quaternion (-> self parent-quat)) (-> (the-as process-drawable (-> self parent 0)) root quat))
  (vector-identity! (-> self root scale))
  (set! (-> self root transv quad) (-> arg2 quad))
  (vector-normalize-copy! (-> self base-vector) arg2 1.0)
  (vector+float*! (-> self target) (-> self root trans) (-> self root transv) 2.0)
  (set! (-> self target-base quad) (-> self target quad))
  (projectile-hl-method-27 self)
  (projectile-hl-method-24 self)

  (set! (-> self event-hook) (-> (method-of-object self projectile-hl-moving) event))
  (projectile-hl-method-25 self)
  (none))

(defun projectile-hl-collision-reaction-stop ((arg0 collide-shape-moving) (arg1 collide-shape-intersect) (arg2 vector) (arg3 vector))
  ;; Instantly stop on any hit
  (send-event (-> arg0 process) 'die)
  (the-as cshape-moving-flags 0))

(defmethod projectile-hl-method-26 ((this projectile-hl))
  (let ((s5-0 (new 'process 'collide-shape-moving this (collide-list-enum hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) projectile-hl-collision-reaction)
    (set! (-> s5-0 no-reaction) (the-as (function collide-shape-moving collide-shape-intersect vector vector none) nothing))
    (let ((s4-0 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> s4-0 prim-core collide-as) (collide-kind projectile))
      (set! (-> s4-0 collide-with) (collide-kind background cak-1 cak-2 cak-3 crate enemy wall-object ground-object mother-spider))
      (set! (-> s4-0 prim-core action) (collide-action attackable))
      (set! (-> s4-0 prim-core offense) (collide-offense normal-attack))
        (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 1000.0)
      (set-root-prim! s5-0 s4-0))
    (backup-collide-with-as s5-0)
    (set! (-> s5-0 max-iteration-count) (the-as uint 2))
    (set! (-> s5-0 event-self) 'touched)
    (set! (-> this root) s5-0))
  0
  (none))
