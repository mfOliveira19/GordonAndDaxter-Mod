;;-*-Lisp-*-
(in-package goal)
(bundles "FIC.DGO" "LAV.DGO" "MIS.DGO" "OGR.DGO" "ROL.DGO")
(require "levels/racer_common/target-racer.gc")
(require "engine/common-obs/babak.gc")
(require "engine/target/target.gc")
(require "levels/racer_common/racer-part.gc")
(require "engine/common-obs/water.gc")
(require "engine/anim/joint-exploder.gc")
(define-extern *race-track-surface* surface)

;; DECOMP BEGINS

(defbehavior racer-hl-thrust target ((arg0 basic) (arg1 float))
  (let ((f0-0 (if (and (or (cpad-hold? (-> self control cpad number) x) (should-move-forward?))
                       (not (-> self racer stick-lock))
                       (not (-> self racer stick-off)))
                1.0
                0.0)))
    (when (< 0.0 f0-0)
      (let ((f1-4 (* f0-0 (+ (-> self control new-surf target-speed) (-> self racer boost-output) (-> self racer hill-boost)))))
        (+! (-> self control ltransv z) (* f1-4 (seconds-per-frame)))))
    (seek! (-> self racer front-rotv) (+ 65536.0 (* 364088.88 (+ f0-0 (/ arg1 10)))) (* 364088.88 (seconds-per-frame))))
  (set! (-> self racer front-rot)
        (the float (sar (shl (the int (+ (-> self racer front-rot) (* (-> self racer front-rotv) (seconds-per-frame)))) 48) 48)))
  (let* ((f1-12 (-> self control new-surf fric))
         (f0-13 (- 1.0 (* (- 1.0 f1-12) (-> *display* time-adjust-ratio)))))
    (set! f0-13
          (cond
            ((and (not (and (= (-> self fact eco-type) (pickup-type eco-yellow)) (>= (-> self fact eco-level) 1.0)))
                  (or (cpad-hold? (-> self control cpad number) square) (should-move-back?)))
             (if (and (or (cpad-hold? (-> self control cpad number) x) (should-move-forward?))
                      (not (-> self racer stick-lock))
                      (not (-> self racer stick-off)))
               ;; og:preserve-this changed for high fps
               (* (- 1.0 (* 0.0125 DISPLAY_FPS_RATIO)) f0-13)
               (* (- 0.5 (* 0.00625 DISPLAY_FPS_RATIO)) (+ 1.0 f0-13))))
            (else
             (cond
               ((and (or (cpad-hold? (-> self control cpad number) x) (should-move-forward?))
                     (not (-> self racer stick-lock))
                     (not (-> self racer stick-off))))
               (else (set! f0-13 (* 0.5 (+ 1.0 f0-13)))))
             f0-13)))
    (set! (-> self control ltransv x) (* (-> self control ltransv x) f0-13))
    (set! (-> self control ltransv z) (* (-> self control ltransv z) f0-13)))
  (let ((f30-0 (-> self racer transv-max)))
    (if (>= (vector-xz-length (-> self control ltransv)) f30-0)
      (vector-xz-normalize! (-> self control ltransv) f30-0)))
  (+! (-> self racer bottom-rot)
      (* (+ 364088.88 (* 0.32 (fabs (-> self control ltransv y)))) (seconds-per-frame)))
  0
  (none))

(defbehavior target-hl-racing-post target ()
  (set! (-> self control reaction) racer-collision-reaction)
  (set! (-> self control surf) *race-track-surface*)
  (set! (-> self racer transv-max)
        (+ (-> self control new-surf transv-max) (-> self racer boost-output) (-> self racer hill-boost)))
  (let ((gp-0 (the int (-> *display* time-ratio))))
    (set-time-ratios *display* 1.0)
    (countdown (s5-0 gp-0)
      (set! (-> self control unknown-int40) s5-0)
      (flag-setup)
      (build-conversions (-> self control transv))
      (racer-service-slide)
;; convert keyboard keys to analog-like float values
(let* ((f30-0 (- (if (should-move-right?) 1.0 0.0)
                 (if (should-move-left?)  1.0 0.0)))  ; left/right
       (f26-2 (- (if (should-move-forward?) 1.0 0.0)
                 (if (should-move-back?)    1.0 0.0)))) ; forward/back

  ;; store x-axis input
  (set! (-> self racer mod-x) f30-0)

  ;; slide / l1-r1 stuff can remain or you can map keyboard buttons if needed
  (let* ((f28-0 (-> self racer slide-amp))
         (v1-17 (-> self racer slide-mode))
         (f28-1 (* f28-0
                   (cond
                     ((zero? v1-17)
                      (- (analog-input (the-as int (-> *cpad-list* cpads (-> self control cpad number) abutton (abutton-idx l1)))
                                                   0.0
                                                   32.0
                                                   255.0
                                                   1.0) 
                                     (analog-input (the-as int (-> *cpad-list* cpads (-> self control cpad number) abutton (abutton-idx r1)))
                                                   0.0
                                                   32.0
                                                   255.0
                                                   1.0)))
                     ((= v1-17 1)
                      (fmax (analog-input (the-as int (-> *cpad-list* cpads (-> self control cpad number) abutton (abutton-idx l1))) ;; og:preserve-this abutton indexing
                                                0.0
                                                32.0
                                                255.0
                                                1.0) 
                                  (analog-input (the-as int (-> *cpad-list* cpads (-> self control cpad number) abutton (abutton-idx r1))) ;; og:preserve-this abutton indexing
                                                0.0
                                                32.0
                                                255.0
                                                1.0)))
                     (else 0.0)))))
    
    ;; optional: allow disabling stick
    (when (-> self racer stick-off)
      (set! f30-0 0.0)
      (set! f26-2 0.0))

    ;; rotate front / tail based on inputs
    (+! (-> self racer front-turn) (* 0.0625 (deg-diff (-> self racer front-turn) (* 3640.889 f30-0))))
    (+! (-> self racer tail-tilt)  (* 0.0625 (deg-diff (-> self racer tail-tilt) (* -3640.889 f26-2))))

    ;; compute xz speeds / thrust
    (let* ((f26-3 (* f30-0 (lerp-scale 5461.3335 7281.778 (-> self control speed-mod) 0.0 (-> self racer transv-max))))
           (f0-29 (* f28-1 (lerp-scale 546.13336 3640.889 (-> self control speed-mod) 0.0 (-> self racer transv-max))))
           (f1-3 (* -0.8 (-> self racer rotv y)))
           (f0-33 (+ (cond ((< (* f1-3 f26-3) 0.0) 0.0)
                           (else (let ((f2-3 (+ 910.2222 (fabs f1-3))))
                                   (fmax (fmin f26-3 f2-3) (- f2-3)))))
                     (cond ((< (* f1-3 f0-29) 0.0) 0.0)
                           (else (let ((f1-5 (+ 910.2222 (fabs f1-3))))
                                   (fmax (fmin f0-29 f1-5) (- f1-5))))))))
      (+! (-> self racer rot z) (* 0.05 (deg-diff (-> self racer rot z) (fmax -7281.778 (fmin 7281.778 f0-33))))))

      ;; apply racer movement
      (racer-xz f30-0 f28-1)
      (racer-hl-thrust (the-as basic f30-0) f28-1)))

      (racer-calc-gravity)
      (add-gravity)
      (reverse-conversions (-> self control transv))
      (let ((f30-1 (/ (* (-> self racer tail-tilt) (+ 20480.0 (-> self control speed-mod))) (+ 20480.0 (-> self racer transv-max)))))
        (cond
          ((racer-on-ground?)
           (seek! (-> self control bend-target) 1.0 (* 8.0 (seconds-per-frame)))
           (seek! (-> self racer mult-rotx) 0.0 (* 2.0 (seconds-per-frame)))
           (set! (-> self racer targ-rotx) 0.0)
           (set! (-> self racer hill-rotx) 0.0)
           (set! (-> self racer speed-rotx) 0.25)
           (let ((f0-52 (-> self racer bob-timer)))
             (let ((f1-16 (+ (-> self racer bob-timer) (* (-> self racer bob-meta-timer) (-> *display* time-adjust-ratio))))
                   (f2-12 (-> self racer bob-period)))
               (set! (-> self racer bob-timer) (- f1-16 (* (the float (the int (/ f1-16 f2-12))) f2-12))))
             (when (!= (the int (/ f0-52 (/ (-> self racer bob-period) 2)))
                       (the int (/ (-> self racer bob-timer) (/ (-> self racer bob-period) 2))))
               (seek! (-> self racer bob-mult-trans) 1.0 0.75)
               (if (< 1.5 (-> self racer bob-meta-meta-timer)) (seek! (-> self racer bob-meta-meta-timer) 1.0 0.5))
               (when (time-elapsed? (-> self racer bob-meta-time) (seconds 2.2))
                 (set-time! (-> self racer bob-meta-time))
                 (set! (-> self racer bob-meta-meta-timer) (rand-vu-float-range 0.8 1.2)))))
           (let ((f0-63 (lerp-scale -1.0 -0.33 (-> self control speed-mod) 0.0 (-> self racer transv-max))))
             (seek! (-> self racer bob-mult-rot) f0-63 (* 8.0 (seconds-per-frame))))
           (if (< 0.0 f30-1) (set! f30-1 0.0))
           (set! (-> self racer stick-lock) #f))
          (else
           (seek! (-> self control bend-target) 0.0 (* 2.0 (seconds-per-frame)))
           (seek! (-> self racer mult-rotx) 1.0 (* 16.0 (seconds-per-frame)))
           (let ((f0-77 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
             (vector-! (new 'stack-no-clear 'vector) (-> self control trans) (the-as vector (-> self control trans-old)))
             (let* ((v1-128 (-> self racer bounce))
                    (f1-36 (cond
                             ((= v1-128 1) (* -0.08888889 f0-77))
                             ((= v1-128 2) (* -0.035555556 f0-77))
                             ((= v1-128 3) (* -0.017777778 f0-77))
                             (else (* -0.13333334 f0-77)))))
               (if (-> self racer hop?) (set! f1-36 (/ f1-36 2)))
               (if (= (-> self control cur-surf mode) 'air)
                 (set! (-> self racer targ-rotx) (fmax -2730.6667 (fmin 5461.3335 f1-36)))))
             (cond
               ((>= f0-77 -32768.0)
                (cond
                  ((or (= (-> self next-state name) 'target-racing-jump)
                       (and (= (-> self next-state name) 'target-racing-bounce) (= (-> self racer bounce) 1)))
                   (set! (-> self racer speed-rotx) 0.5)
                   (when (time-elapsed? (-> self control last-ground-time) (seconds 0.1))
                     (seek! (-> self racer hill-rotx) 0.0 (* 65536.0 (seconds-per-frame)))
                     (set! (-> self racer speed-rotx) 0.6)))
                  (else (set! (-> self racer speed-rotx) 0.25)))
                (seek! (-> self racer mult-rotx) 1.0 (* 64.0 (seconds-per-frame))))
               (else (set! (-> self racer speed-rotx) 0.025))))
           (let ((f0-91 (+ (-> self racer bob-timer) (* (-> self racer bob-meta-timer) (-> *display* time-adjust-ratio))))
                 (f1-44 (-> self racer bob-period)))
             (set! (-> self racer bob-timer) (- f0-91 (* (the float (the int (/ f0-91 f1-44))) f1-44))))
           (seek! (-> self racer bob-mult-rot) 0.0 (* 16.0 (seconds-per-frame)))
           (seek! (-> self racer bob-mult-trans) 0.0 (* 16.0 (seconds-per-frame)))
           (set! f30-1 (lerp-scale f30-1 1820.4445 (the float (- (current-time) (-> self control last-ground-time))) 0.0 900.0))
           (cond
             ((and (logtest? (-> self control status) (cshape-moving-flags twall))
                   (and (time-elapsed? (-> self control last-ground-time) (seconds 0.1))
                        (or (-> self racer stick-lock) (< (target-move-dist (-> *TARGET-bank* stuck-time)) 4096.0))
                        (not (and (= *cheat-mode* 'debug) (cpad-hold? (-> self control cpad number) r2)))))
              (cond
                ((and (< 0.0
                         (vector-dot (-> self control dynam gravity-normal)
                                     (vector-! (new 'stack-no-clear 'vector) (-> self control trans) (-> self control last-known-safe-ground))))
                      (logtest? (-> self control root-prim prim-core action) (collide-action racer-grounded)))
                 (+! (-> self racer stuck-count) 1)
                 (go target-racing-smack 122880.0 #f))
                (else (set! (-> self racer stick-lock) #t))))
             (else (set! (-> self racer stick-lock) #f)))))
        (+! (-> self racer lean-rotx) (* 0.1 (deg-diff (-> self racer lean-rotx) f30-1))))
      (set! (-> self racer lean-rotx) 0.0)
      (set! (-> self racer rot-old quad) (-> self racer rot quad))
      (set! (-> self racer change-roty-old) (-> self racer change-roty))
      (set! (-> self racer rot y)
            (the float (sar (shl (the int (+ (-> self racer rot y) (* (-> self racer rotv y) (seconds-per-frame)))) 48) 48)))
      (set! (-> self racer change-roty)
            (* (deg-diff (-> self racer rot-old y) (-> self racer rot y)) (-> *display* frames-per-second)))
      (racer-collision)
      (racer-integrate)
      (post-flag-setup))
    (set-time-ratios *display* (the float gp-0)))
  (target-compute-slopes *up-vector*)
  (racer-effects)
  (racer-sounds)
  (rot->dir-targ! (-> self control))
  (racer-bend-gravity)
  (ja-post)
  (joint-points)
  (do-target-shadow)
  (target-powerup-process)
  (vector+! (-> self racer bike-trans) (-> self control trans) (-> self control racer-cushion))
  (quaternion-copy! (the-as quaternion (-> self racer bike-quat)) (-> self control quat))
  (set! (-> self racer bike-scale quad) (-> self control scale quad))
  (let ((v1-240 (-> *target-shadow-control* settings shadow-dir quad)))
    (set! (-> *racer-shadow-control* settings shadow-dir quad) v1-240))
    
  #|(let ((cam-pos (new 'stack-no-clear 'vector)))
    (vector-copy! cam-pos (-> self control trans))
    (+! (-> cam-pos y) 10000.0)
    (-! (-> cam-pos z) 5000.0)
    (set! (-> (&-> (-> self control) unknown-qword00) 0) (-> cam-pos quad)))|#
0
  (none))

(defstate target-hl-racing-start (target)
  :event
    (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
      (cond
        ((and (= message 'query) (= (-> block param 0) 'mode)) 'racer)
        ((and (= message 'get-pickup) (= (-> block param 0) 3))
         (if (time-elapsed? (-> self racer boost-time) (seconds 1))
           (send-event self 'boost (fmax 1.0 (fmin 2.0 (the-as float (-> block param 1)))))))
        (else
         (case message
           (('end-mode) (go target-hl-racing-get-off (process->handle proc)))
           (('touched)
            (send-event proc 'attack (-> block param 0) 'racer 0 0)
            (when (and (type-type? (-> proc type) babak) (< 40960.0 (-> self control speed-mod)))
              (let ((f0-5 (lerp-scale 16384.0 32768.0 (-> self control speed-mod) 40960.0 (-> self racer transv-max))))
                (go target-hl-racing-jump f0-5 f0-5 #f))))
           (('attack 'attack-or-shove 'attack-invinc)
            (let ((v1-27 (the-as attack-info (-> block param 1))))
              (if (not (and (logtest? (-> v1-27 mask) (attack-mask mode)) (or (= (-> v1-27 mode) 'burn) (= (-> v1-27 mode) 'burnup))))
                (target-attacked message
                                 (the-as attack-info (-> block param 1))
                                 proc
                                 (the-as touching-shapes-entry (-> block param 0))
                                 (the-as (state symbol attack-info target) target-hl-racing-hit)))))
           (('heat)
            (set! (-> self racer heat)
                  (fmax 0.0 (fmin (+ (-> self racer heat) (the-as float (-> block param 0))) (-> *RACER-bank* heat-max)))))
           (('boost)
            (sound-play "get-blue-eco")
            (set! (-> self racer boost-sound-id) (sound-play "zoom-boost"))
            (set-time! (-> self racer boost-time))
            (set! (-> self racer boost-level)
                  (seek (-> self racer boost-level)
                        (-> *RACER-bank* boost-level-max)
                        (* (-> *RACER-bank* boost-level-inc) (the-as float (-> block param 0))))))
           (('smack) (go target-hl-racing-smack (-> self control speed-mod) #t))
           (('jump) (go target-hl-racing-jump (the-as float (-> block param 0)) (the-as float (-> block param 1)) #f))
           (('change-mode)
            (case (-> block param 0)
              (('grab) (go target-hl-racing-grab))))
           (('clone-anim) (go target-hl-racing-clone-anim (process->handle (the-as process (-> block param 0)))))
           (else (target-hl-generic-event-handler proc argc message block))))))
  :exit
    (behavior ()
      (when (not (or (= (-> self next-state name) 'target-hl-racing)
                     (= (-> self next-state name) 'target-hl-racing-jump)
                     (= (-> self next-state name) 'target-hl-racing-bounce)
                     (= (-> self next-state name) 'target-hl-racing-hit)
                     (= (-> self next-state name) 'target-hl-racing-death)
                     (= (-> self next-state name) 'target-hl-racing-smack)
                     (= (-> self next-state name) 'target-hl-racing-falling)
                     (= (-> self next-state name) 'target-hl-racing-get-on)
                     (= (-> self next-state name) 'target-hl-racing-get-off)
                     (= (-> self next-state name) 'target-hl-racing-get-off-jump)
                     (= (-> self next-state name) 'target-hl-racing-grab)
                     (= (-> self next-state name) 'target-hl-racing-clone-anim)))
        (let ((v1-25 (-> self manipy)))
          (when v1-25
            (deactivate (-> v1-25 0))
            (set! (-> self manipy) (the-as (pointer manipy) #f))))
        (let ((v1-29 (-> *hud-parts* bike-speed)))
          (when v1-29
            (set! (-> v1-29 0 deactivate-when-hidden) #t)
            (send-event (ppointer->process v1-29) 'hide-quick)))
        (let ((v1-32 (-> *hud-parts* bike-heat)))
          (when v1-32
            (set! (-> v1-32 0 deactivate-when-hidden) #t)
            (send-event (ppointer->process v1-32) 'hide-quick)))
        (set! (-> *hud-parts* buzzers 0 next-y-offset) 0)
        (set! (-> *hud-parts* power 0 next-y-offset) 0)
        (set! (-> *hud-parts* buzzers 0 y-sgn) 1)
        (set! (-> *hud-parts* power 0 y-sgn) 1)
        (logclear! (-> self control root-prim prim-core action) (collide-action racer racer-unused))
        (set! (-> self control cur-surf) *walk-mods*)
        (logclear! (-> self state-flags) (state-flags use-alt-cam-pos))
        (send-event *camera* 'clear-slave-option #x6000)
        (set! (-> self control dynam gravity-max) (-> self control cur-dynam gravity-max))
        (set! (-> self control dynam gravity-length) (-> self control cur-dynam gravity-length))
        (let ((v1-60 (-> self node-list data)))
          (set! (-> v1-60 0 param0) cspace<-transformq+trans!)
          (set! (-> v1-60 0 param1) (the-as basic (-> self control trans)))
          (set! (-> v1-60 0 param2) (the-as basic (-> self control racer-cushion))))
        (target-collide-set! 'normal 0.0)
        (set! (-> self control reaction) target-collision-reaction)
        (sound-stop (-> self racer engine-sound-id))
        (set! (-> self racer engine-sound-id) (new 'static 'sound-id))
        (set! (-> self control racer-cushion quad) (the-as uint128 0))
        (remove-setting! 'sound-flava)
        (target-exit)))
  :code
    (behavior ((arg0 handle))
      (target-exit)
      (set! *display-profile* #f)
      (set! *display-entity-errors* #f)
      (set-setting! 'sound-flava #f 30.0 (music-flava racer))
      (if (zero? (-> self racer)) (set! (-> self racer) (new 'process 'racer-info)))
      (set! (-> self racer turn-anim-targ) 0.0)
      (set! (-> self racer turn-anim-frame) 0.0)
      (set! (-> self racer turn-anim-vel) 0.0)
      (set! (-> self racer tail-anim-vel) 0.0)
      (set! (-> self racer tail-anim-frame) 0.0)
      (set! (-> self racer rudd-anim-vel) 0.0)
      (set! (-> self racer rudd-anim-frame) 0.0)
      (set! (-> self racer stick-lock) #f)
      (set! (-> self racer stick-off) #f)
      (set! (-> self racer heavy) #f)
      (set-time! (-> self racer unstuck-time))
      (set! (-> self racer stuck-count) 0)
      (set! (-> self racer cushion-base) 10240.0)
      (set! (-> self racer shock-offset) 0.0)
      (set! (-> self racer shock-offsetv) 0.0)
      (set! (-> self racer shock-rotx) 0.0)
      (set! (-> self racer engine-sound-id) (new 'static 'sound-id))
      (set! (-> self racer boost-sound-id) (new 'static 'sound-id))
      (set! (-> self racer scrape-sound-id) (new-sound-id))
      (set! (-> self racer entity) #f)
      (let ((v1-28 (handle->process arg0))) 
        (if (and (not *allow-zoomer-anywhere*) v1-28) ;; OG-modbase dont track entity, prevents crash on level deload
          (set! (-> self racer entity) (-> v1-28 entity))))
      (set! (-> self control surf) *race-track-surface*)
      (set! (-> self control reaction) racer-collision-reaction)
      (vector-reset! (-> self racer rot))
      (set! (-> self racer rot y) (y-angle (-> self control)))
      (target-collide-set! 'racer 0.0)
      (set! (-> self control transv quad) (the-as uint128 0))
      (set! (-> self control speed-mod) 0.0)
      (logior! (-> self control root-prim prim-core action) (collide-action racer))
      (set! (-> self control cur-surf) *racer-mods*)
      (set! (-> self racer lean-rotx) 0.0)
      (vector-reset! (-> self racer rotv))
      (quaternion-identity! (the-as quaternion (-> self racer surface-quat)))
      (quaternion-identity! (the-as quaternion (-> self racer surface-quat-smooth)))
      (set! (-> self racer front-rot) (-> *RACER-bank* default-front-blade))
      (set! (-> self racer front-rotv) 0.0)
      (set! (-> self racer bottom-rot) 0.0)
      (let ((v1-56 (-> self node-list data)))
        (set! (-> v1-56 0 param0) cspace<-transformq+world-trans!)
        (set! (-> v1-56 0 param1) (the-as basic (-> self control trans)))
        (set! (-> v1-56 0 param2) (the-as basic (-> self control racer-cushion))))
      (set! (-> self control bend-target) 1.0)
      (set! (-> self racer hop?) #f)
      (set! (-> self racer bounce) 0)
      (set! (-> self racer bounce-hit) 0.0)
      (set! (-> self racer bob-period) 900.0)
      (set! (-> self racer bob-mult-rot) 0.0)
      (set! (-> self racer bob-mult-trans) 0.0)
      (set! (-> self racer bob-meta-timer) 0.0)
      (set! (-> self racer bob-meta-meta-timer) 0.0)
      (set! (-> self racer bob-hit-ground-time) 0)
      (set! (-> self racer cushion-bob) 0.0)
      (set! (-> self racer cushion-bob-old) 0.0)
      (set! (-> self racer hill-value) 0.0)
      (set! (-> self racer hill-ground-value) 0.0)
      (set! (-> self racer hill-offset) 0.0)
      (set! (-> self racer hill-boost) 0.0)
      (set! (-> self racer cur-rotx) 0.0)
      (set! (-> self racer targ-rotx) 0.0)
      (set! (-> self racer hill-rotx) 0.0)
      (set! (-> self racer mult-rotx) 0.0)
      (set! (-> self racer speed-rotx) 0.25)
      (set! (-> self racer boost-curve) 0.0)
      (set! (-> self racer boost-level) 0.0)
      (set! (-> self racer boost-target) 0.0)
      (set! (-> self racer boost-output) 0.0)
      (set! (-> self racer boost-time) 0)
      (set! (-> self racer boost-duration) (-> *RACER-bank* boost-duration))
      (set! (-> self racer heat) 0.0)
      (set! (-> self racer slide-mode) 0)
      (set! (-> self racer slide-amp) 0.0)
      (set! (-> self racer slide-down-time 0) 0)
      (set! (-> self racer slide-down-time 1) 0)
      (set! (-> self racer slide-interp) 0.0)
      (set! (-> self racer surface-y) (-> self control trans y))
      (let ((s5-0 (-> self entity)))
        (set! (-> self entity) (-> self racer entity))
        (set! (-> self manipy)
              (manipy-spawn (-> self control trans) (-> self entity) *racer-sg* #f :from *8k-dead-pool* :to self))
        (set! (-> self entity) s5-0))
      (when (-> self manipy)
        (send-event (ppointer->process (-> self manipy))
                    'trans-hook
                    (lambda :behavior manipy ()
                      (let ((v1-0 (ppointer->process (-> self parent))))
                        (set! (-> self root trans quad) (-> (the-as target v1-0) racer bike-trans quad))
                        (let ((a0-4 (-> (the-as target v1-0) racer bike-quat quad))) (set! (-> self root quat vec quad) a0-4))
                        (set! (-> self root scale quad) (-> (the-as target v1-0) racer bike-scale quad))
                        (set! (-> self draw light-index) (the-as uint 255))
                        (let ((a0-9 (-> (the-as target v1-0) draw color-mult quad))) (set! (-> self draw color-mult quad) a0-9))
                        (let ((a0-11 (-> (the-as target v1-0) draw color-emissive quad))) (set! (-> self draw color-emissive quad) a0-11))
                        (set! (-> self draw secondary-interp) (-> (the-as target v1-0) draw secondary-interp)))))
        (send-event (ppointer->process (-> self manipy)) 'anim-mode 'loop)
        (send-event (ppointer->process (-> self manipy)) 'art-joint-anim "racer-get-on" 0.0)
        (send-event (ppointer->process (-> self manipy))
                    'eval
                    (lambda :behavior manipy ()
                      (set! (-> self clone-copy-trans) #f)
                      (let ((v1-1 (-> *target-shadow-control* settings shadow-dir quad)))
                        (set! (-> *racer-shadow-control* settings shadow-dir quad) v1-1))
                      (set! (-> self draw shadow-ctrl) *racer-shadow-control*)
                      (let ((gp-0 (-> self parent)))
                        (set! (-> (the-as target (-> gp-0 0)) racer front-blade) (new 'process 'joint-mod (joint-mod-handler-mode rotate) self 4))
                        (set! (-> (the-as target (-> gp-0 0)) racer bottom-blade)
                              (new 'process 'joint-mod (joint-mod-handler-mode rotate) self 10))
                        (let ((v0-2 (new 'process 'joint-mod (joint-mod-handler-mode rotate) self 7)))
                          (set! (-> (the-as target (-> gp-0 0)) racer tail) v0-2)
                          v0-2)))))
      (set-twist! (-> self racer front-blade) (the-as float #f) (- (-> self racer front-rot)) (the-as float #f))
      (set-twist! (-> self racer bottom-blade) (the-as float #f) (the-as float #f) (- (-> self racer bottom-rot)))
      (remove-exit)
      (go target-hl-racing-get-on arg0))
  :post target-post)

(defbehavior target-hl-racing-smack-check target ()
  (if (and (< 20480.0 (-> self control speed-mod))
           (and (logtest? (-> self control status) (cshape-moving-flags twall))
                (< (-> self control surface-angle) 0.5)
                (let ((gp-1 (vector-! (new 'stack-no-clear 'vector) (-> self control wall-intersect) (-> self control trans)))
                      (s5-0 (new 'stack-no-clear 'vector)))
                  (set! (-> s5-0 quad) (-> self control last-transv quad))
                  (set! (-> gp-1 y) 0.0)
                  (set! (-> s5-0 y) 0.0)
                  (vector-xz-normalize! gp-1 1.0)
                  (vector-xz-normalize! s5-0 1.0)
                  (< 0.87 (vector-dot gp-1 s5-0)))))
    (go target-hl-racing-smack (-> self control speed-mod) #t))
  (none))

(defstate target-hl-racing (target)
  :event
    (-> target-hl-racing-start
        event)
  :enter
    (behavior ()
      (set! (-> self control cur-surf) *racer-mods*))
  :exit
    (behavior ()
      (target-racing-center-anim)
      ((-> target-hl-racing-start exit)))
  :trans
    (behavior ()
      ;; og:preserve-this - High FPS Fix
      (if (and (or (recently-pressed? l1 r1) (should-jump?))
               (or (not (time-elapsed? (-> self control last-ground-time) (seconds 0.1)))
                   (< (vector-dot (-> self control dynam gravity-normal)
                                  (vector-! (new 'stack-no-clear 'vector) (-> self control trans) (-> self control shadow-pos)))
                      4096.0)))
        (go target-hl-racing-jump 2048.0 5324.8 #t))
      (target-hl-racing-smack-check)
      (let* ((f30-0 (target-height-above-ground))
             (v1-28 (time-to-ground (vector-dot (-> self control dynam gravity-normal) (-> self control transv))
                                    (-> self control dynam gravity-length)
                                    f30-0)))
        (if (and (not (logtest? (-> self control status) (cshape-moving-flags onsurf)))
                 (or (time-elapsed? (-> self control last-ground-time) (* (-> *TARGET-bank* ground-timeout) 2)) (< 75 v1-28))
                 (< 30 v1-28)
                 (< 4096.0 f30-0))
          (go target-hl-racing-falling)))
      (set! (-> self racer turn-anim-targ) (* 20.0 (-> self racer mod-x)))
      (racer-buzz (+ 0.45 (* 1.7 (fabs (-> self racer slide-shift-x))))))
  :code
    (behavior ()
      (cond
        ((ja-group? eichar-racer-get-on-ja) (ja-no-eval :num! (seek!)) (while (not (ja-done? 0)) (suspend) (ja-eval)))
        ((let ((v1-16 (ja-group)))
           (or (or (= v1-16 eichar-racer-jump-small-ja) (= v1-16 eichar-racer-jump-small-loop-ja)) (> (-> self racer bounce) 0)))
         (let ((s5-0 #f)
               (gp-0 #f))
           (when (and (< (fabs (-> self racer bob-mult-trans)) 0.2)
                      (and (time-elapsed? (-> self racer racing-time) (seconds 0.15)) (< 16384.0 (-> self control ground-impact-vel))))
             (when (>= (-> self control speed-mod) 40960.0)
               (set! (-> *part-id-table* 2225 init-specs 1 initial-valuef) 100.0)
               (launch-particles (-> *part-id-table* 2225) (-> self control trans)))
             (target-land-effect)
             (when (and (>= (-> self control ground-impact-vel) 61440.0) (zero? (-> self racer bounce)))
               (set! (-> self racer bounce) 0)
               (set! (-> self racer bounce-hit) (-> self control ground-impact-vel)))
             (when (< (-> self racer bounce-hit) 73728.0)
               (set! (-> self racer bounce) 0)
               0)
             (set! (-> self racer bob-timer) 90.0)
             (let ((f0-14 (lerp-scale 2.0 3.0 (-> self control speed-mod) 0.0 (-> self racer transv-max))))
               (set! (-> self racer bob-meta-meta-timer) f0-14)
               (set! (-> self racer bob-meta-timer) f0-14))
             (set! (-> self racer bob-mult-trans) (lerp-scale 0.2 2.5 (-> self control ground-impact-vel) 20480.0 81920.0))
             (set-time! (-> self racer bob-hit-ground-time))
             (set-time! (-> self racer bob-meta-time))
             (cond
               ((or s5-0 (and (>= (-> self racer bounce) 1) (< (-> self racer bounce) 2)))
                (+! (-> self racer bounce) 1)
                (let* ((v1-73 (-> self racer bounce))
                       (a1-6 (cond
                               ((= v1-73 1) (lerp-scale 4096.0 8192.0 (-> self racer bounce-hit) 61440.0 81920.0))
                               ((= v1-73 2) 2048.0))))
                  (go target-hl-racing-bounce a1-6 a1-6 gp-0)))
               ((>= (-> self racer slide-mode) 0))
               (else (target-racing-land-anim gp-0)))))))
      (when (!= (-> self racer slide-shift-x) 0.0)
        (if (rand-vu-percent? 0.5) (sound-play "zoomer-rev1" :vol 80) (sound-play "zoomer-rev2" :vol 80)))
      (set! (-> self racer bounce) 0)
      (loop
        (let ((gp-3 (current-time)))
          (when (not (ja-group? eichar-racer-turn-ja))
            (ja-channel-push! 4 (seconds 0.1))
            (ja :group! eichar-racer-turn-ja :num! (identity (ja-aframe (-> self racer turn-anim-frame) 0)))
            (ja :chan 1 :group! eichar-racer-turn2-ja :num! (chan 0))
            (ja :chan 2 :group! eichar-racer-dig-ja :num! (chan 0))
            (ja :chan 3 :group! eichar-racer-dig2-ja :num! (chan 0)))
          (while (not (time-elapsed? gp-3 (seconds 1)))
            (if (or (!= (-> *cpad-list* cpads (-> self control cpad number) stick0-speed) 0.0)
                    (or (cpad-hold? (-> self control cpad number) l1 r1 x) (>= (fabs (-> self racer turn-anim-frame)) 1.0)))
              (set! gp-3 (current-time)))
            (target-racing-turn-anim)
            (suspend)))
        (when (not (ja-group? eichar-racer-stance-ja))
          (ja-channel-push! 1 (seconds 0.4))
          (ja :group! eichar-racer-stance-ja :num! min))
        (while (not (or (!= (-> *cpad-list* cpads (-> self control cpad number) stick0-speed) 0.0)
                        (or (cpad-hold? (-> self control cpad number) l1 r1 x) (>= (fabs (-> self racer turn-anim-frame)) 1.0))))
          (suspend)
          (ja :num! (loop!)))))
  :post
    (behavior ()
      (if (= (-> self next-state name) 'target-hl-racing) (set-time! (-> self racer racing-time)))
      (target-hl-racing-post)))

(defstate target-hl-racing-jump (target)
  :event
    (-> target-hl-racing-start
        event)
  :enter
    (behavior ((arg0 float) (arg1 float) (arg2 symbol))
      (set! (-> self racer shock-offsetv) 0.0)
      (sound-play "zoomer-jump")
      (set-time! (-> self state-time))
      (when arg2
        (when (>= (-> self racer hill-ground-value) 0.11)
          (set! (-> self racer hill-boost) (* 40960.0 (-> self racer hill-ground-value)))
          (vector-normalize! (-> self control transv) (+ (-> self control speed-mod) (-> self racer hill-boost)))))
      (if (and (logtest? (-> self control status) (cshape-moving-flags onsurf)) (< 16384.0 (-> self control transv y)))
        (set! (-> self racer hop?) #f)
        (set! (-> self racer hop?) arg2))
      (set! (-> self racer hop-start-y) (-> self control trans y))
      (racer-calc-gravity)
      (init-var-jump arg0 arg1 (the-as vector #t) (the-as vector #f) (-> self control transv))
      (logclear! (-> self control status) (cshape-moving-flags onsurf onground tsurf))
      (set! (-> self control cur-surf) *racer-air-mods*)
      (set! (-> self control turn-vec-len3)
            (fmax 0.0 (fmin 1.0 (* 0.00004359654 (+ -11468.8 (-> self control speed-mod))))))
      (if (< (-> self racer slide-mode) 0)
        (set! (-> self racer slide-down-time 0)
              (the-as time-frame (if (cpad-hold? (-> self control cpad number) l1 r1) (the-as int (current-time)) 0)))))
  :exit
    (behavior ()
      (logclear! (-> self control root-prim prim-core action) (collide-action racer-grounded))
      (set! (-> self racer hop?) #f)
      ((-> target-hl-racing-start exit)))
  :trans
    (behavior ()
      (set! (-> self control turn-vec-len3)
            (fmax (-> self control turn-vec-len3)
                  (* 0.003921569 (the float (-> *cpad-list* cpads (-> self control cpad number) abutton (abutton-idx x)))))) ;; og:preserve-this abutton indexing
      (cond
        ((cpad-pressed? (-> self control cpad number) l1 r1) (set-time! (-> self racer slide-down-time 0)))
        ((not (cpad-hold? (-> self control cpad number) l1 r1)) (set! (-> self racer slide-down-time 0) 0) 0)
        ((and (time-elapsed? (-> self racer slide-down-time 0) (the-as time-frame (-> *RACER-bank* slide-hold-time)))
              (< (-> self racer slide-mode) 0)
              (or (< (-> *cpad-list* cpads (-> self control cpad number) leftx) (the-as uint 64))
                  (< (the-as uint 192) (-> *cpad-list* cpads (-> self control cpad number) leftx))))
         (set! (-> self racer slide-mode)
               (if (< (-> *cpad-list* cpads (-> self control cpad number) leftx) (the-as uint 64)) 0 1))
         (set-time! (-> self racer slide-enter-time))
         (set! (-> self racer slide-amp) 1.0)
         (set! (-> self racer slide-grip-mult) 0.0))
        ((>= (-> self racer slide-mode) 0)
         (cond
           ((< (-> *cpad-list* cpads (-> self control cpad number) leftx) (the-as uint 64))
            (set! (-> self racer slide-mode) 0)
            0)
           ((< (the-as uint 192) (-> *cpad-list* cpads (-> self control cpad number) leftx))
            (set! (-> self racer slide-mode) 1)))))
      (if (and (logtest? (-> self control status) (cshape-moving-flags onsurf))
               (time-elapsed? (-> self state-time) (seconds 0.1)))
        (go target-hl-racing))
      (if (or (< (-> self control trans y) (-> self racer hop-start-y))
              (< 10240.0
                 (vector-dot (-> self control dynam gravity-normal)
                             (vector-! (new 'stack-no-clear 'vector) (-> self control trans) (-> self control shadow-pos)))))
        (set! (-> self racer hop?) #f))
      (target-hl-racing-smack-check)
      (if (time-elapsed? (-> self state-time) (seconds 1))
        (logior! (-> self control root-prim prim-core action) (collide-action racer-grounded)))
      (mod-var-jump #t #t (cpad-hold? (-> self control cpad number) l1 r1) (-> self control transv))
      (set! (-> self racer shock-offset) (* 0.8 (-> self racer shock-offset)))
      (racer-buzz 0.4))
  :code
    (behavior ((arg0 float) (arg1 float) (arg2 symbol))
      (let ((a0-1 (if (< 0.1 (-> self racer hill-value)) 'jump))) (target-racing-jump-anim a0-1 (seconds 0.2))))
  :post
    (-> target-hl-racing
        post))

(defstate target-hl-racing-bounce (target)
  :event
    (-> target-hl-racing-start
        event)
  :enter
    (behavior ((arg0 float) (arg1 float) (arg2 symbol))
      (logior! (-> self control root-prim prim-core action) (collide-action racer-grounded))
      (sound-play "zoomer-jump")
      (set-time! (-> self state-time))
      (racer-calc-gravity)
      (init-var-jump arg0 arg1 (the-as vector #t) (the-as vector #f) (-> self control transv))
      (logclear! (-> self control status) (cshape-moving-flags onsurf onground tsurf))
      (set! (-> self control turn-vec-len3)
            (fmax 0.0 (fmin 1.0 (* 0.00004359654 (+ -11468.8 (-> self control speed-mod)))))))
  :exit
    (behavior ()
      (logclear! (-> self control root-prim prim-core action) (collide-action racer-grounded))
      ((-> target-hl-racing-start exit)))
  :trans
    (behavior ()
      (set! (-> self control turn-vec-len3)
            (fmax (-> self control turn-vec-len3)
                  (* 0.003921569 (the float (-> *cpad-list* cpads (-> self control cpad number) abutton (abutton-idx x)))))) ;; og:preserve-this abutton indexing
      ;; og:preserve-this - High FPS Fix
      (if (and (or (recently-pressed? l1 r1) (should-jump?))
               (or (not (time-elapsed? (-> self control last-ground-time) (seconds 0.2)))
                   (< (vector-dot (-> self control dynam gravity-normal)
                                  (vector-! (new 'stack-no-clear 'vector) (-> self control trans) (-> self control shadow-pos)))
                      8192.0)))
        (go target-hl-racing-jump 2048.0 5324.8 #t))
      (if (and (logtest? (-> self control status) (cshape-moving-flags onsurf))
               (time-elapsed? (-> self state-time) (seconds 0.1)))
        (go target-hl-racing))
      (mod-var-jump #t #t (cpad-hold? (-> self control cpad number) l1 r1) (-> self control transv))
      (target-hl-racing-smack-check)
      (racer-buzz 0.4))
  :code
    (behavior ((arg0 float) (arg1 float) (arg2 symbol))
      (target-racing-land-anim arg2)
      (when (not (ja-group? eichar-racer-turn-ja))
        (ja-channel-push! 4 (seconds 0.1))
        (ja :group! eichar-racer-turn-ja :num! (identity (ja-aframe (-> self racer turn-anim-frame) 0)))
        (ja :chan 1 :group! eichar-racer-turn2-ja :num! (chan 0))
        (ja :chan 2 :group! eichar-racer-dig-ja :num! (chan 0))
        (ja :chan 3 :group! eichar-racer-dig2-ja :num! (chan 0)))
      (loop
        (target-racing-turn-anim)
        (suspend)))
  :post
    (-> target-hl-racing
        post))

(defstate target-hl-racing-smack (target)
  :event
    (-> target-hl-racing-start
        event)
  :enter
    (behavior ((arg0 float) (arg1 symbol))
      (sound-play "smack-surface")
      (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 255 (seconds 0.5))
      (set! (-> self racer heavy) arg1)
      (vector-! (-> self control transv) (-> self control wall-intersect) (-> self control trans))
      (let ((f0-0 (lerp-scale 0.0 -61440.0 arg0 0.0 163840.0)))
        (if (cpad-hold? (-> self control cpad number) x) (set! f0-0 (* 2.0 f0-0)))
        (vector-normalize! (-> self control transv) f0-0))
      (set! (-> self racer boost-curve) 0.0)
      (set! (-> self racer boost-level) 0.0)
      (set! (-> self racer boost-target) 0.0)
      (set! (-> self racer boost-output) 0.0)
      (set! (-> self racer boost-time) 0)
      0)
  :exit
    (behavior ()
      (set! (-> self racer heavy) #f)
      ((-> target-hl-racing-start exit)))
  :trans
    (behavior ()
      (set! (-> self racer turn-anim-targ) 0.0))
  :code
    (behavior ((arg0 float) (arg1 symbol))
      (sound-play "zoomer-crash-2")
      (ja-channel-push! 2 (seconds 0.05))
      (ja-no-eval :group! eichar-racer-smack-ja :num! (seek!))
      (ja :chan 1
          :group!
          eichar-racer-idle-ja
          :num!
          (identity (ja-aframe 0.0 0))
          :frame-interp
          (lerp-scale 1.0 0.25 arg0 0.0 122880.0))
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek! max (lerp-scale 2.0 1.0 arg0 0.0 163840.0))))
      (go target-hl-racing))
  :post
    (-> target-hl-racing
        post))

(defstate target-hl-racing-falling (target)
  :event
    (-> target-hl-racing-start
        event)
  :enter
    (behavior ()
      (set! (-> self control cur-surf) *racer-air-mods*)
      (set-time! (-> self state-time)))
  :exit
    (behavior ()
      (logclear! (-> self control root-prim prim-core action) (collide-action racer-grounded))
      ((-> target-hl-racing-start exit)))
  :trans
    (behavior ()
      (if (logtest? (-> self control status) (cshape-moving-flags onsurf)) (go target-hl-racing))
      (target-hl-racing-smack-check)
      (racer-buzz 0.3)
      (if (time-elapsed? (-> self state-time) (seconds 1))
        (logior! (-> self control root-prim prim-core action) (collide-action racer-grounded))))
  :code
    (behavior ()
      (target-racing-jump-anim #f (seconds 0.1)))
  :post
    (-> target-hl-racing
        post))

(defstate target-hl-racing-hit (target)
  :event target-hl-generic-event-handler
  :enter
    (behavior ((arg0 handle) (arg1 attack-info))
      (let ((v1-0 (-> self attack-info)))
        (set! (-> v1-0 attacker) arg0)
        (set! (-> v1-0 mode) 'generic)
        (set! (-> v1-0 shove-back) 6144.0)
        (set! (-> v1-0 shove-up) 4915.2)
        (set! (-> v1-0 angle) #f))
      (set! (-> self attack-info trans quad) (the-as uint128 0))
      (combine! (-> self attack-info) arg1)
      (case (-> self attack-info mode)
        (('endlessfall 'death 'explode 'water-vol 'heat 'melt 'instant-death)
         (pickup-collectable! (-> self fact) (pickup-type eco-green) -1000.0 (the-as handle #f)))
        (else
         (pickup-collectable! (-> self fact) (pickup-type eco-green) (- (-> *FACT-bank* health-single-inc)) (the-as handle #f)))))
  :exit
    (behavior ()
      (if (!= (-> self next-state name) 'target-hl-racing-death)
        (logclear! (-> self state-flags) (state-flags being-attacked dying)))
      ((-> target-hl-racing-start exit)))
  :code
    (behavior ((arg0 handle) (arg1 attack-info))
      (target-timed-invulnerable (-> *TARGET-bank* hit-invulnerable-timeout) self)
      (when (!= (-> self attack-info mode) 'endlessfall)
        (effect-control-method-10 (-> self skel effect) 'group-target-hit -1.0 -1)
        (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 255 (seconds 0.3))
        (sound-play "oof"))
      (set-time! (-> self game hit-time))
      (logior! (-> self state-flags) (state-flags being-attacked))
      (set! (-> self racer boost-curve) 0.0)
      (set! (-> self racer boost-level) 0.0)
      (set! (-> self racer boost-target) 0.0)
      (set! (-> self racer boost-output) 0.0)
      (set! (-> self racer boost-time) 0)
      (if (and (= (-> self game mode) 'play) (>= 0.0 (-> self fact health))) (go target-hl-racing-death (-> self attack-info mode)))
      (case (-> self attack-info mode)
        (('endlessfall))
        (('darkeco)
         (let ((s5-1 (new 'stack-no-clear 'vector)))
           (set! (-> s5-1 quad) (-> self control transv quad))
           (let ((a2-3 (vector-xz-normalize! (vector-! (new 'stack-no-clear 'vector) (-> self control trans) (-> self attack-info intersection))
                                             1.0)))
             (set! (-> a2-3 y) 0.0)
             (let ((gp-1 (vector-reflect-flat! (new 'stack-no-clear 'vector) s5-1 a2-3))
                   (f30-0 (vector-xz-length s5-1)))
               (set! (-> gp-1 y) 0.0)
               (vector-normalize! gp-1 1.0)
               (vector-normalize-copy! (-> self control transv) gp-1 (* 2.0 f30-0))
               (let ((f28-0 (deg-diff (-> self racer rot y) (vector-y-angle gp-1))))
                 (if (< 16384.0 (fabs f28-0)) (set! f28-0 (deg-diff (-> self racer rot y) (+ 32768.0 (vector-y-angle gp-1)))))
                 (set! (-> self racer rotv y) (* f28-0 (lerp-scale 4.0 7.0 f30-0 4096.0 (-> self racer transv-max)))))))))
        (else
         (set! (-> self post-hook) target-hl-racing-post)
         (ja-channel-push! 1 (seconds 0.05))
         (ja-no-eval :group! eichar-racer-smack-ja :num! (seek!) :frame-num 0.0)
         (until (ja-done? 0)
           (suspend)
           (ja :num! (seek!)))))
      (go target-hl-racing))
  :post target-no-stick-post)

(defstate target-hl-racing-death (target)
  :event
    (-> target-death
        event)
  :exit
    (behavior ()
      (logclear! (-> self state-flags) (state-flags dying))
      (send-event (ppointer->process (-> self manipy)) 'draw #t)
      (send-event (ppointer->process (-> self manipy)) 'anim-mode 'clone-anim)
      (target-timed-invulnerable-off self)
      (set! (-> self control pat-ignore-mask) (new 'static 'pat-surface :noentity #x1))
      (restore-collide-with-as (-> self control))
      ((-> target-hl-racing-start exit))
      (target-exit)
      (set! (-> self racer stick-off) #f))
  :code
    (behavior ((arg0 symbol))
      (local-vars (v1-154 symbol))
      (set! (-> self racer stick-off) #t)
      (set! (-> self neck flex-blend) 0.0)
      (target-timed-invulnerable-off self)
      (logior! (-> self state-flags) (state-flags dying))
      (case (-> self attack-info mode)
        (('explode 'darkeco 'heat 'death 'deadly 'balloonlurker)
         ((-> target-hl-racing-start exit))
         (send-event (ppointer->process (-> self manipy)) 'anim-mode 'loop)
         (send-event (ppointer->process (-> self manipy)) 'draw #f)
         (sound-play "zoomer-explode")
         (process-spawn part-tracker
                        :init
                        part-tracker-init
                        (-> *part-group-id-table* 116)
                        -1
                        #f
                        #f
                        #f
                        (-> self control trans)
                        :to
                        *entity-pool*)
         (send-event (ppointer->process (-> self manipy))
                     'eval
                     (lambda :behavior racer ()
                       (let ((s5-0 (-> self parent-override))
                             (gp-0 (new 'stack 'joint-exploder-tuning 1)))
                         (let* ((f0-0 (vector-length (-> s5-0 0 control transv)))
                                (f30-0 (fmin 1.0 (/ f0-0 (meters 30)))))
                           (set! (-> gp-0 duration) (seconds 5))
                           (set! (-> gp-0 fountain-rand-transv-hi x) (fmax 24576.0 f0-0))
                           (set! (-> gp-0 fountain-rand-transv-hi y) (+ 81920.0 f0-0))
                           (set! (-> gp-0 fountain-rand-transv-hi z) 20480.0)
                           (set! (-> gp-0 fountain-rand-transv-hi w) 36864.0)
                           (vector-negate! (-> gp-0 fountain-rand-transv-lo) (-> s5-0 0 control transv))
                           (vector-normalize! (-> gp-0 fountain-rand-transv-lo) (* 12288.0 f30-0)))
                         (vector+! (-> gp-0 fountain-rand-transv-lo) (-> gp-0 fountain-rand-transv-lo) (-> s5-0 0 control trans))
                         (process-spawn joint-exploder
                                        *racer-explode-sg*
                                        24
                                        gp-0
                                        (new 'static
                                             'joint-exploder-static-params
                                             :joints
                                             (new 'static
                                                  'boxed-array
                                                  :type
                                                  joint-exploder-static-joint-params
                                                  (new 'static 'joint-exploder-static-joint-params :joint-index 3 :parent-joint-index -1)
                                                  (new 'static 'joint-exploder-static-joint-params :joint-index 4 :parent-joint-index -1)
                                                  (new 'static 'joint-exploder-static-joint-params :joint-index 5 :parent-joint-index -1)
                                                  (new 'static 'joint-exploder-static-joint-params :joint-index 6 :parent-joint-index -1)
                                                  (new 'static 'joint-exploder-static-joint-params :joint-index 7 :parent-joint-index -1)
                                                  (new 'static 'joint-exploder-static-joint-params :joint-index 8 :parent-joint-index -1)
                                                  (new 'static 'joint-exploder-static-joint-params :joint-index 9 :parent-joint-index -1)
                                                  (new 'static 'joint-exploder-static-joint-params :joint-index 10 :parent-joint-index -1)
                                                  (new 'static 'joint-exploder-static-joint-params :joint-index 11 :parent-joint-index -1)
                                                  (new 'static 'joint-exploder-static-joint-params :joint-index 12 :parent-joint-index -1)
                                                  (new 'static 'joint-exploder-static-joint-params :joint-index 13 :parent-joint-index -1)
                                                  (new 'static 'joint-exploder-static-joint-params :joint-index 14 :parent-joint-index -1)
                                                  (new 'static 'joint-exploder-static-joint-params :joint-index 15 :parent-joint-index -1)
                                                  (new 'static 'joint-exploder-static-joint-params :joint-index 16 :parent-joint-index -1)
                                                  (new 'static 'joint-exploder-static-joint-params :joint-index 17 :parent-joint-index -1)
                                                  (new 'static 'joint-exploder-static-joint-params :joint-index 18 :parent-joint-index -1)))
                                        :to
                                        self))))
         (ja-channel-push! 1 (seconds 0.1))
         (fmax -182044.44 (fmin 182044.44 (* -40.0 (-> self racer rot z))))
         (case (-> self attack-info mode)
           (('balloonlurker)
            (create-splash (-> self water) 2.0 (-> self control trans) 1 (-> self control transv))
            (ja-no-eval :group! eichar-racer-death-explode-ja :num! (seek! (ja-aframe 240.0 0)) :frame-num 0.0)
            (until (ja-done? 0)
              (set! (-> self racer stick-lock) #t)
              (seek! (-> self control racer-cushion-targ y) 6144.0 (* 12288.0 (seconds-per-frame)))
              (send-event *camera* 'joystick 0.0 1.0)
              (suspend)
              (ja :num! (seek! (ja-aframe 240.0 0)))))
           (else
            (ja-no-eval :group! eichar-racer-death-explode-ja :num! (seek!) :frame-num 0.0)
            (until (ja-done? 0)
              (set! (-> self racer stick-lock) #t)
              (send-event *camera* 'joystick 0.0 1.0)
              (seek! (-> self control racer-cushion-targ y) 6144.0 (* 12288.0 (seconds-per-frame)))
              (if (>= (ja-aframe-num 0) 245.0) (set-forward-vel (/ (-> self control speed-mod) 2)))
              (suspend)
              (ja :num! (seek!))))))
        (('melt)
         (sound-play "zoomer-melt")
         (process-spawn part-tracker
                        :init
                        part-tracker-init
                        (-> *part-group-id-table* 32)
                        -1
                        #f
                        #f
                        #f
                        (-> self control trans)
                        :to
                        *entity-pool*)
         (clear-collide-with-as (-> self control))
         (set! (-> self post-hook) target-no-ja-move-post)
         (ja-channel-set! 0)
         (ja-post)
         (suspend-for (seconds 2)))
        (('endlessfall)
         (sound-play "death-fall")
         (camera-change-to (the-as string cam-endlessfall) 30 #f)
         (set! (-> self control pat-ignore-mask unknown-bit) 1)
         (let ((f30-0 (fmin -4096.0 (- (-> self control ground-impact-vel)))))
           (let ((gp-8 (new-stack-vector0)))
             (let ((f0-28 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
               0.0
               (vector-! gp-8 (-> self control transv) (vector-float*! gp-8 (-> self control dynam gravity-normal) f0-28)))
             (let* ((f0-29 (vector-length gp-8))
                    (f1-9 f0-29)
                    (f2-2 f30-0))
               (vector+! (-> self control transv)
                         (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f2-2)
                         (vector-float*! gp-8 gp-8 (/ f0-29 f1-9)))))
           (suspend-for (seconds 0.75)
             (vector-seek! (-> self draw color-mult) *zero-vector* (* 1.5 (seconds-per-frame)))
             (set-forward-vel (* 0.96 (-> self control speed-mod)))
             (let ((s5-3 (new-stack-vector0))
                   (f28-0 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
               0.0
               (vector-! s5-3 (-> self control transv) (vector-float*! s5-3 (-> self control dynam gravity-normal) f28-0))
               (let* ((f0-38 (vector-length s5-3))
                      (f1-12 f0-38))
                 (if (< f30-0 f28-0) (set! f28-0 f30-0))
                 (vector+! (-> self control transv)
                           (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f28-0)
                           (vector-float*! s5-3 s5-3 (/ f0-38 f1-12)))))))
         (camera-change-to (the-as string 'base) 0 #f)))
      (set! (-> self control transv quad) (the-as uint128 0))
      (set! (-> self control speed-mod) 0.0)
      (set! (-> self post-hook) target-no-stick-post)
      (initialize! (-> self game) 'dead (the-as game-save #f) (the-as string #f))
      (set-time! (-> self state-time))
      (until v1-154
        (suspend)
        (set! v1-154
              (and (time-elapsed? (-> self state-time) (seconds 1))
                   (not (logtest? (-> *kernel-context* prevent-from-run) (process-mask movie))))))
      (go target-hl-movement-ground))
  :post target-hl-racing-post)

(defstate target-hl-racing-get-on (target)
  :event target-hl-generic-event-handler
  :exit
    (-> target-hl-racing-start
        exit)
  :code
    (behavior ((arg0 handle))
      (set! (-> self control transv quad) (the-as uint128 0))
      (set! (-> self alt-cam-pos quad) (-> (&-> (-> self control) unknown-qword00) 0))
      (logior! (-> self state-flags) (state-flags use-alt-cam-pos))
      (set-time! (-> self state-time))
      (let ((gp-0 (new 'stack-no-clear 'vector)))
        (set! (-> gp-0 quad) (-> self control trans quad))
        (let ((s5-0 (new 'stack-no-clear 'vector)))
          (set! (-> s5-0 quad) (-> self control trans quad))
          (quaternion-copy! (-> self control unknown-quaternion02) (-> self control quat))
          (quaternion-copy! (-> self control unknown-quaternion03) (-> self control quat-targ))
          (set! (-> self control temp-flop-end-checks) (the-as uint (-> self control racer-cushion-targ y)))
          (let* ((s3-0 (handle->process arg0))
                 (s4-1 (if (and (nonzero? s3-0) (type-type? (-> s3-0 type) process-drawable)) (the-as racer s3-0))))
            (when s4-1
              (set! (-> s5-0 quad) (-> s4-1 root trans quad))
              (quaternion-copy! (-> self control unknown-quaternion03) (-> s4-1 root quat))
              (send-event s4-1 'trans (-> self racer bike-trans))
              (quaternion-copy! (the-as quaternion (-> self racer bike-quat)) (-> s4-1 root quat))
              (set! (-> self racer bike-scale quad) (-> s4-1 root scale quad))
              (set! (-> self control unknown-int21) (the-as int (-> self racer bike-trans y)))))
          (set! (-> self control last-transv2 quad) (-> gp-0 quad))
          (set! (-> self control last-transv3 quad) (-> s5-0 quad))))
      (let ((s5-1 #f)
            (gp-1 #f))
        (ja-channel-push! 1 (seconds 0.05))
        (ja-no-eval :group! eichar-racer-get-on-ja :num! (seek! (ja-aframe 77.0 0)) :frame-num 0.0)
        (until (ja-done? 0)
          (when (and (not s5-1) (= (-> self skel root-channel 0) (-> self skel channel)))
            (send-event (ppointer->process (-> self manipy)) 'anim-mode 'clone-anim)
            (set! s5-1 #t))
          (set! (-> self control transv quad) (the-as uint128 0))
          (when (< 50.0 (ja-aframe-num 0))
            (when (not gp-1)
              (sound-play "zoomer-start")
              (set! gp-1 #t))
            (set! (-> self racer front-rotv) 65536.0)
            (set! (-> self racer front-rot)
                  (the float (sar (shl (the int (+ (-> self racer front-rot) (* (-> self racer front-rotv) (seconds-per-frame)))) 48) 48)))
            (+! (-> self racer bottom-rot) (* 364088.88 (seconds-per-frame)))
            (set-twist! (-> self racer front-blade) (the-as float #f) (- (-> self racer front-rot)) (the-as float #f))
            (set-twist! (-> self racer bottom-blade) (the-as float #f) (the-as float #f) (- (-> self racer bottom-rot))))
          (suspend)
          (ja :num! (seek! (ja-aframe 77.0 0)))))
      (logclear! (-> self state-flags) (state-flags use-alt-cam-pos))
      (send-event *camera* 'set-slave-option #x6000)
      (set! (-> self control transv quad) (the-as uint128 0))
      (quaternion-copy! (-> self control quat) (-> self control quat-targ))
      (rot->dir-targ! (-> self control))
      (set! (-> self racer rot y) (y-angle (-> self control)))
      (when *target*
        (when (or (= (-> *target* current-level name) 'lavatube)
                  (= (-> *target* current-level name) 'firecanyon)
                  (= (-> *target* current-level name) 'citadel))
          (set! (-> *hud-parts* bike-heat) (process-spawn hud-bike-heat :init hud-init-by-other 0 :to self))
          (set! (-> *hud-parts* buzzers 0 next-y-offset) -120)
          (set! (-> *hud-parts* buzzers 0 y-sgn) 0)
          0)
        (set! (-> *hud-parts* bike-speed) (process-spawn hud-bike-speed :init hud-init-by-other 0 :to self))
        (set! (-> *hud-parts* power 0 next-y-offset) -120)
        (set! (-> *hud-parts* power 0 y-sgn) 0)
        0)
      (go target-hl-racing))
  :post
    (behavior ()
      (let ((gp-0 (new 'stack-no-clear 'vector))
            (f30-0 (fmin 1.0 (* 0.0044444446 (the float (- (current-time) (-> self state-time)))))))
        (vector-lerp! gp-0 (-> self control last-transv2) (-> self control last-transv3) f30-0)
        (set! (-> gp-0 y)
              (lerp (-> self control last-transv2 y)
                    (-> self control last-transv3 y)
                    (fmax 0.0 (fmin 1.0 (* 0.0044444446 (the float (+ (- (seconds -0.5) (-> self state-time)) (current-time))))))))
        (move-to-point! (-> self control) gp-0)
        (quaternion-slerp! (-> self control quat-targ)
                           (-> self control unknown-quaternion02)
                           (-> self control unknown-quaternion03)
                           f30-0))
      (let ((f30-1 (fmax 0.0 (fmin 1.0 (* 0.010528533 (+ -279.99 (the float (- (current-time) (-> self state-time)))))))))
        (set! (-> self control racer-cushion-targ y)
              (lerp (the-as float (-> self control temp-flop-end-checks)) (-> self racer cushion-base) f30-1))
        (set! (-> self racer bike-trans y)
              (lerp (the-as float (-> self control unknown-uint30)) (+ 4096.0 (the-as float (-> self control unknown-uint30))) f30-1)))
      (hide-hud-quick)
      (target-no-move-post)))

(defstate target-hl-racing-get-off (target)
  :event target-hl-generic-event-handler
  :exit
    (-> target-hl-racing-start
        exit)
  :code
    (behavior ((arg0 handle))
      (set-time! (-> self state-time))
      (set! (-> self control cur-surf) *racer-mods*)
      (let ((a0-2 (-> *hud-parts* bike-speed))) (if a0-2 (set! (-> a0-2 0 deactivate-when-hidden) #t)))
      (let ((a0-4 (-> *hud-parts* bike-heat))) (if a0-4 (set! (-> a0-4 0 deactivate-when-hidden) #t)))
      (when (not (ja-group? eichar-racer-turn-ja))
        (ja-channel-push! 4 (seconds 0.1))
        (ja :group! eichar-racer-turn-ja :num! (identity (ja-aframe (-> self racer turn-anim-frame) 0)))
        (ja :chan 1 :group! eichar-racer-turn2-ja :num! (chan 0))
        (ja :chan 2 :group! eichar-racer-dig-ja :num! (chan 0))
        (ja :chan 3 :group! eichar-racer-dig2-ja :num! (chan 0)))
      (suspend-for (seconds 0.5)
        (set! (-> self racer stick-lock) #t)
        (set-forward-vel (* 0.9 (-> self control speed-mod)))
        (set! (-> self racer turn-anim-targ) 0.0)
        (set! (-> self racer turn-anim-targ) 0.0)
        (target-racing-turn-anim)
        (seek! (-> self control racer-cushion-targ y) 6144.0 (* 3.0 (seconds-per-frame))))
      (go target-hl-racing-get-off-jump arg0))
  :post target-hl-racing-post)

(defstate target-hl-racing-get-off-jump (target)
  :event target-hl-generic-event-handler
  :exit
    (-> target-hl-racing-start
        exit)
  :code
    (behavior ((arg0 handle))
      (sound-play "zoomer-stop")
      (set-time! (-> self state-time))
      (set! (-> self control transv quad) (the-as uint128 0))
      (let ((gp-1 (new 'stack-no-clear 'vector)))
        (set! (-> gp-1 quad) (-> self control trans quad))
        (let ((s4-1 (new 'stack-no-clear 'vector)))
          (set! (-> s4-1 quad) (-> self control trans quad))
          (quaternion-copy! (-> self control unknown-quaternion02) (-> self control quat))
          (quaternion-copy! (-> self control unknown-quaternion03) (-> self control quat-targ))
          (set! (-> self control temp-flop-end-checks) (the-as uint (-> self control racer-cushion-targ y)))
          (let* ((s2-0 (handle->process arg0))
                 (s3-0 (if (and (nonzero? s2-0) (type-type? (-> s2-0 type) process-drawable)) (the-as racer s2-0))))
            (when s3-0
              (set! (-> s4-1 quad) (-> s3-0 root trans quad))
              (set-yaw-angle-clear-roll-pitch! (-> s3-0 root) (quaternion-y-angle (-> self control quat)))
              (quaternion-copy! (-> self control unknown-quaternion03) (-> s3-0 root quat))
              (send-event s3-0 'trans (-> self racer bike-trans))
              (quaternion-copy! (the-as quaternion (-> self racer bike-quat)) (-> s3-0 root quat))
              (set! (-> self racer bike-scale quad) (-> s3-0 root scale quad))
              (set! (-> self control unknown-int21) (the-as int (-> self racer bike-trans y)))))
          (set! (-> self control last-transv2 quad) (-> gp-1 quad))
          (set! (-> self control last-transv3 quad) (-> s4-1 quad)))
        (ja-channel-push! 1 (seconds 0.05))
        (ja-no-eval :group! eichar-racer-get-off-ja :num! (seek!) :frame-num 0.0)
        (until (ja-done? 0)
          (suspend)
          (ja :num! (seek!)))
        (send-event (handle->process arg0) 'draw)
        (set-yaw-angle-clear-roll-pitch! (-> self control) (quaternion-y-angle (-> self control unknown-quaternion03)))
        (rot->dir-targ! (-> self control))
        (ja-post)
        (vector<-cspace! gp-1 (joint-node eichar-lod0-jg main))
        (+! (-> gp-1 y) -5896.192)
        (move-to-point! (-> self control) gp-1))
      (send-event *camera* 'ease-in)
      (ja-channel-set! 0)
      (go target-hl-racing-get-off-hit-ground #f))
  :post
    (behavior ()
      (let* ((f0-2 (deg-diff (-> self racer front-rot) (-> *RACER-bank* default-front-blade)))
             (f0-5 (if (< 0.0 f0-2) (fmax 5461.3335 (* 4.0 f0-2)) 54613.332)))
        (seek! (-> self racer front-rotv) f0-5 (* 54613.332 (seconds-per-frame))))
      (set! (-> self racer front-rot)
            (the float (sar (shl (the int (+ (-> self racer front-rot) (* (-> self racer front-rotv) (seconds-per-frame)))) 48) 48)))
      (when (and (< (fabs (deg-diff (-> *RACER-bank* default-front-blade) (-> self racer front-rot))) 1820.4445)
                 (= (-> self racer front-rotv) 5461.3335))
        (set! (-> self racer front-rotv) 0.0)
        (set! (-> self racer front-rot) (-> *RACER-bank* default-front-blade)))
      (+! (-> self racer bottom-rot) (* 364088.88 (seconds-per-frame)))
      (set-twist! (-> self racer front-blade) (the-as float #f) (- (-> self racer front-rot)) (the-as float #f))
      (set-twist! (-> self racer bottom-blade) (the-as float #f) (the-as float #f) (- (-> self racer bottom-rot)))
      (let ((gp-0 (new 'stack-no-clear 'vector))
            (f30-0 (fmax 0.0 (fmin 1.0 (* 0.004761905 (+ -150.0 (the float (- (current-time) (-> self state-time)))))))))
        (fmax 0.0 (fmin 1.0 (* 0.006666667 (+ -225.0 (the float (- (current-time) (-> self state-time)))))))
        (vector-lerp! gp-0 (-> self control last-transv2) (-> self control last-transv3) f30-0)
        (set! (-> gp-0 y)
              (lerp (-> self control last-transv2 y)
                    (-> self control last-transv3 y)
                    (fmax 0.0 (fmin 1.0 (* 0.0044444446 (the float (+ (- (seconds -0.5) (-> self state-time)) (current-time))))))))
        (move-to-point! (-> self control) gp-0)
        (quaternion-slerp! (-> self control quat-targ)
                           (-> self control unknown-quaternion02)
                           (-> self control unknown-quaternion03)
                           f30-0)
        (set! (-> self control racer-cushion-targ y)
              (lerp (the-as float (-> self control temp-flop-end-checks)) 6144.0 (fmin 1.0 (* 2.0 f30-0)))))
      (vector+! (-> self racer bike-trans) (-> self control trans) (-> self control racer-cushion))
      (quaternion-copy! (the-as quaternion (-> self racer bike-quat)) (-> self control quat))
      (set! (-> self racer bike-scale quad) (-> self control scale quad))
      (hide-hud)
      (target-no-move-post)))

(defstate target-hl-racing-get-off-hit-ground (target)
  :event target-hl-standard-event-handler
  :enter
    (-> target-hit-ground
        enter)
  :trans
    (behavior ()
      (logior! (-> self control status) (cshape-moving-flags onsurf onground tsurf))
      ((-> target-hit-ground trans)))
  :code
    (behavior ((arg0 symbol))
      (ja-channel-set! 1)
      (ja-no-eval :group! eichar-jump-land-ja :num! (seek!) :frame-num (ja-aframe 42.0 0))
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!)))
      (go target-hl-movement-ground))
  :post
    (behavior ()
      (hide-hud)
      (target-post)))

(defstate target-hl-racing-grab (target)
  :event
    (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
      (cond
        ((and (= message 'query) (= (-> block param 0) 'mode)) (-> self state name))
        (else
         (case message
           (('end-mode) (go target-hl-racing))
           (('clone-anim) (go target-hl-racing-clone-anim (process->handle (the-as process (-> block param 0)))))
           (else (target-hl-generic-event-handler proc argc message block))))))
  :enter
    (behavior ()
      (set! (-> self control cur-surf) *grab-mods*)
      (set! (-> self neck flex-blend) 0.0)
      (logior! (-> self state-flags) (state-flags invulnerable grabbed))
      (set! (-> self racer stick-off) #t))
  :exit
    (behavior ()
      (set! (-> self racer stick-off) #f)
      (logclear! (-> self state-flags) (state-flags invulnerable grabbed))
      (logclear! (-> self water flags) (water-flags wt16))
      ((-> target-hl-racing-start exit)))
  :code
    (behavior ()
      (when (not (ja-group? eichar-racer-turn-ja))
        (ja-channel-push! 4 (seconds 0.1))
        (ja :group! eichar-racer-turn-ja :num! (identity (ja-aframe (-> self racer turn-anim-frame) 0)))
        (ja :chan 1 :group! eichar-racer-turn2-ja :num! (chan 0))
        (ja :chan 2 :group! eichar-racer-dig-ja :num! (chan 0))
        (ja :chan 3 :group! eichar-racer-dig2-ja :num! (chan 0)))
      (loop
        (target-racing-turn-anim)
        (set-forward-vel 0.0)
        (suspend)))
  :post target-hl-racing-post)

(defstate target-hl-racing-clone-anim (target)
  :event
    (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
      (if (and (= message 'trans) (= (-> block param 0) 'restore)) (set! (-> self control temp-flop-end-checks) (the-as uint #f)))
      ((-> target-hl-racing-grab event) proc argc message block))
  :enter
    (-> target-clone-anim
        enter)
  :exit
    (behavior ()
      (set! (-> self control racer-cushion-targ y) (the-as float (-> self control temp-flop-end-checks)))
      (set! (-> self control racer-cushion y) (-> self control racer-cushion-targ y))
      (send-event (ppointer->process (-> self sidekick)) 'matrix #f)
      ((-> target-clone-anim exit))
      ((-> target-hl-racing-start exit))
      (vector-reset! (-> self control transv)))
  :code
    (behavior ((arg0 handle))
      (set! (-> self control temp-flop-end-checks) (the-as uint (-> self control racer-cushion-targ y)))
      (set! (-> self control racer-cushion-targ y) 0.0)
      (send-event (ppointer->process (-> self sidekick)) 'matrix 'play-anim)
      (clone-anim arg0 33 #t "")
      (go target-hl-racing))
  :post
    (behavior ()
      (racer-sounds)
      (seek! (-> self racer heat) 0.0 (* (-> *RACER-bank* surface-heat-inc) (seconds-per-frame)))
      (vector+! (-> self racer bike-trans) (-> self control trans) (-> self control racer-cushion))
      (quaternion-copy! (the-as quaternion (-> self racer bike-quat)) (-> self control quat))
      (set! (-> self racer bike-scale quad) (-> self control scale quad))
      (target-no-ja-move-post)))
